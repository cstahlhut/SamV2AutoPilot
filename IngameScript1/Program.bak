using Sandbox.ModAPI.Ingame;
using SpaceEngineers.Game.ModAPI.Ingame;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using VRage.Game.ModAPI.Ingame;
using VRageMath;

namespace IngameScript
{
    internal partial class Program : MyGridProgram
    {
        // This file contains your actual script.
        //
        // You can either keep all your code here, or you can create separate
        // code files to make your program easier to navigate while coding.
        //
        // In order to add a new utility class, right-click on your project,
        // select 'New' then 'Add Item...'. Now find the 'Space Engineers'
        // category under 'Visual C# Items' on the left hand side, and select
        // 'Utility Class' in the main area. Name it in the box below, and
        // press OK. This utility class will be merged in with your code when
        // deploying your final script.
        //
        // You can also simply create a new utility class manually, you don't
        // have to use the template if you don't want to. Just do so the first
        // time to see what a utility class looks like.
        //
        // Go to:
        // https://github.com/malware-dev/MDK-SE/wiki/Quick-Introduction-to-Space-Engineers-Ingame-Scripts
        //
        // to learn more about ingame scripts.

        // Sam's Autopilot Manager
        public static string VERSION = "2.TC1.7";

        //
        // Original Creator: Sam (Magistrator)
        // Significant changes (2022+) TechCoder
        //
        // Documentation: http://steamcommunity.com/sharedfiles/filedetails/?id=1653875433
        // TechCoder's patches, fixes and more = https://discord.gg/Tjw9FrPgUP
        //
        // Navigation modes: UNDOCKING -> [TAXIING] -> [ NAVIGATING | CONVERGING ] -> APPROACHING-> [TAXIING] -> DOCKING
        //   NAVIGATING -> Used when obstacles are detected in the path.
        //   CONVERGING -> Used when no obstacles are detected in the path.
        //   TAXIING    -> Only during Path docking.
        //

        /*
		 What's new:
			+ Significant cleanup of Remote Command section to make it a LOT more user-informative (PB screen now shows updates and errors making troubleshooting easier)
			+ fixed a bug in SAM where it would resize text on any other LOG
			+ New version naming convention fixes earlier SAM.LOG issues
			+ fixed some screen format issues
		 */
        /* Previous significant versions
			2.11.1TC1.0 - initial release of TechCoder mod to make RC commands work
			2.11.1TC1.2 - fixed issue with Programming Block not showing 'Command executed' when using LCD
			2.11.1TC1.4 - fixed issue with Timer Notifications not recognizing "STARTED" and "UNDOCKED"
			2.11.1TC1.5 - added a fix for "crashing into connector" issues for more reliable 'close' connections
		*/

        /// /////////////////////////////////  SPECIAL INSTRUCTIONS FOR USING REMOTE CONTROL COMMANDS ON A SERVER
        // TO USE SAM REMOTE COMMANDS, YOU MUST HAVE AN LCD WITH "S.A.M.RC" IN THE CUSTOM DATA
        /// /////////////////////////////////  /// /////////////////////////////////  /// /////////////////////////////////

        // Change the tag used to identify blocks
        public static string TAG = "SAM";

        // -------------------------------------------------------
        // Update at your own peril.
        // -------------------------------------------------------
        private static float HORIZONT_CHECK_DISTANCE = 2000.0f; // How far the script will check for obstacles.

        private static float MAX_SPEED = 95.0f; // Used for NAVIGATING and CONVERGING.
        private static float APPROACHING_SPEED = 95.0f;
        private static float TAXIING_SPEED = 10.0f;
        private static float DOCKING_SPEED = 2.5f;

        private static float APPROACH_DISTANCE = 500.0f; // Ship will start approach mode at this distance.
        private static float TAXIING_DISTANCE = 10.0f; // How close will the ship get before starting the docking procedure.
        private static float TAXIING_PANEL_DISTANCE = 5.0f; // When using Path-Docking, the distance from the panel.
        private static float DOCK_DISTANCE = 5.0f; // Ship will start docking at this distance.
        private static float UNDOCK_DISTANCE = 10.0f; // Ship will undock to this distance.

        private static int LOG_MAX_LINES = 30;

        // -------------------------------------------------------
        // Avoid touching anything below this. Things will break.
        // -------------------------------------------------------
        private static string CHARGE_TARGET_GROUP_NAME = "Charge Target";

        private static float DISTANCE_CHECK_TOLERANCE = 0.15f; // Script will assume the ship has reached the target position once the distance is lower than this.
        private static double ROTATION_CHECK_TOLERANCE = 0.015; // Scrip will assume the ship has reached the target rotation once the rotation thresholds are lower than this.
        private static float COLLISION_CORRECTION_ANGLE = (float)Math.PI / 7.5f;
        private static float HORIZONT_CHECK_ANGLE_LIMIT = (float)Math.PI / 32.0f;
        private static float HORIZONT_CHECK_ANGLE_STEP = (float)Math.PI / 75.0f;
        private static float HORIZONT_MAX_UP_ANGLE = (float)Math.PI;
        private static float COLLISION_DISABLE_RADIUS_MULTIPLIER = 2.0f;

        private static double GYRO_GAIN = 1.0;
        private static double GYRO_MAX_ANGULAR_VELOCITY = Math.PI;
        private static float GUIDANCE_MIN_AIM_DISTANCE = 0.5f;
        private static float DISTANCE_TO_GROUND_IGNORE_PLANET = 1.2f * HORIZONT_CHECK_DISTANCE;
        private static int DOCK_ATTEMPTS = 5;
        private static string ADVERT_ID = "SAMv2";
        private static string ADVERT_ID_VER = "SAMv2V";
        private static string STORAGE_VERSION = "deadbeef";
        private static string CMD_TAG = TAG + "CMD";
        private static string CMD_RES_TAG = TAG + "CMDRES";
        private static string LEADER_TAG = TAG + "LEADER";
        private List<IMyTextPanel> lcds = new List<IMyTextPanel>();
        private IMyTextPanel lcd;
        private bool lcdfound = false;
        private static float IDLE_POWER = 0.0000001f;
        private static double TICK_TIME = 0.166666f;
        private static double Ʌ = 1.66666f;

        private static class Raytracer
        { // Raytracer
            public enum Result
            {
                NotRun, NoHit, Hit
            };

            public static Vector3D hitPosition;
            public static MyDetectedEntityInfo hit;

            public static Result Trace(ref Vector3D target, bool ignorePlanet)
            {
                foreach (IMyCameraBlock camera in GridBlocks.cameraBlocks)
                {
                    if (!camera.CanScan(target))
                    {
                        continue;
                    }
                    hit = camera.Raycast(target);
                    if (hit.IsEmpty())
                    {
                        return Result.NoHit;
                    }
                    if (hit.EntityId == GridBlocks.masterProgrammableBlock.CubeGrid.EntityId)
                    {
                        continue;
                    }
                    switch (hit.Type)
                    {
                        case MyDetectedEntityType.Planet:
                            if (ignorePlanet)
                            {
                                return Result.NoHit;
                            }
                            goto case MyDetectedEntityType.SmallGrid;
                        case MyDetectedEntityType.Asteroid:
                        case MyDetectedEntityType.LargeGrid:
                        case MyDetectedEntityType.SmallGrid:
                            hitPosition = hit.HitPosition.Value;
                            return Result.Hit;

                        default:
                            return Result.NoHit;
                    }
                }
                return Result.NotRun;
            }
        }

        private static class Situation
        { // Situation
            public static bool ignoreGravity;
            public static Vector3D position;
            public static Vector3D linearVelocity;
            public static double elevationVelocity;
            public static Vector3D naturalGravity;
            public static bool planetDetected;
            public static Vector3D planetCenter = new Vector3D();
            public static bool inGravity;
            public static double distanceToGround;
            public static double radius;
            public static float mass;
            public static Vector3D gravityUpVector;
            public static Vector3D gravityDownVector;
            public static Vector3D upVector;
            public static Vector3D forwardVector;
            public static Vector3D backwardVector;
            public static Vector3D downVector;
            public static Vector3D rightVector;
            public static Vector3D leftVector;
            public static MatrixD orientation;
            public static Vector3D gridForwardVect;
            public static Vector3D gridUpVect;
            public static Vector3D gridLeftVect;

            private static Dictionary<Base6Directions.Direction, double> maxThrust = new Dictionary<Base6Directions.Direction, double>(){
                {Base6Directions.Direction.Backward,0},
                {Base6Directions.Direction.Down,0},
                {Base6Directions.Direction.Forward,0},
                {Base6Directions.Direction.Left,0},
                {Base6Directions.Direction.Right,0},
                {Base6Directions.Direction.Up,0},
            };

            public static double GetMaxThrust(Vector3D dir)
            {
                var remoteControl = RemoteControl.block.WorldMatrix.GetClosestDirection(-dir);
                return maxThrust.Where(t => t.Value != 0 && t.Key != remoteControl).Min(ş => ş.Value);
            }

            public static void RefreshParameters()
            {
                foreach (Base6Directions.Direction ɾ in maxThrust.Keys.ToList())
                {
                    maxThrust[ɾ] = 0;
                }
                foreach (IMyThrust thruster in GridBlocks.thrusterBlocks)
                {
                    thruster.Enabled = true;
                    if (!thruster.IsWorking)
                    {
                        continue;
                    }
                    maxThrust[thruster.Orientation.Forward] += thruster.MaxEffectiveThrust;
                }
                gridForwardVect = RemoteControl.block.CubeGrid.WorldMatrix.GetDirectionVector(Base6Directions.Direction.Forward);
                gridUpVect = RemoteControl.block.CubeGrid.WorldMatrix.GetDirectionVector(Base6Directions.Direction.Up);
                gridLeftVect = RemoteControl.block.CubeGrid.WorldMatrix.GetDirectionVector(Base6Directions.Direction.Left);
                mass = RemoteControl.block.CalculateShipMass().PhysicalMass;
                position = RemoteControl.block.CenterOfMass;
                orientation = RemoteControl.block.WorldMatrix.GetOrientation();
                radius = RemoteControl.block.CubeGrid.WorldVolume.Radius;
                forwardVector = RemoteControl.block.WorldMatrix.Forward;
                backwardVector = RemoteControl.block.WorldMatrix.Backward;
                rightVector = RemoteControl.block.WorldMatrix.Right;
                leftVector = RemoteControl.block.WorldMatrix.Left;
                upVector = RemoteControl.block.WorldMatrix.Up;
                downVector = RemoteControl.block.WorldMatrix.Down;
                linearVelocity = RemoteControl.block.GetShipVelocities().LinearVelocity;
                elevationVelocity = Vector3D.Dot(linearVelocity, upVector);
                planetDetected = RemoteControl.block.TryGetPlanetPosition(out planetCenter);
                naturalGravity = RemoteControl.block.GetNaturalGravity();
                inGravity = naturalGravity.Length() >= 0.5;
                if (inGravity)
                {
                    RemoteControl.block.TryGetPlanetElevation(MyPlanetElevation.Surface, out distanceToGround);
                    gravityDownVector = Vector3D.Normalize(naturalGravity);
                    gravityUpVector = -1 * gravityDownVector;
                }
                else
                {
                    distanceToGround = DISTANCE_TO_GROUND_IGNORE_PLANET;
                    gravityDownVector = downVector;
                    gravityUpVector = upVector;
                }
            }
        }

        private static class Horizont
        { // Horizont
            public static float angle = 0.0f;
            public static bool hit = false;
            private static bool ignorePlanet;
            private static Vector3D tracePosition;
            private static float angleDir = 1.0f;
            private static float up = 1.0f, down = 1.0f, mult = 1.0f;

            public static Vector3D? ScanHorizont(float distance, Vector3D forwardVector, Vector3D rightVector)
            {
                tracePosition = Situation.position + Math.Min(distance, HORIZONT_CHECK_DISTANCE) * Vector3D.Transform(forwardVector, Quaternion.CreateFromAxisAngle(rightVector, angle));
                ignorePlanet = Situation.distanceToGround >= DISTANCE_TO_GROUND_IGNORE_PLANET;
                if (hit)
                {
                    switch (Raytracer.Trace(ref tracePosition, ignorePlanet))
                    {
                        case Raytracer.Result.Hit:
                            angle += HORIZONT_CHECK_ANGLE_STEP * up;
                            up = Math.Min(10.0f, up + 1.0f);
                            down = 1.0f;
                            mult = 1.0f;
                            angle = (float)Math.Min(HORIZONT_MAX_UP_ANGLE, angle);
                            return Vector3D.Transform(forwardVector, Quaternion.CreateFromAxisAngle(rightVector, angle));

                        case Raytracer.Result.NoHit:
                            angle -= HORIZONT_CHECK_ANGLE_STEP * down;
                            down = Math.Min(10.0f, down + 1.0f);
                            up = 1.0f;
                            mult = 1.0f;
                            if (angle < -HORIZONT_CHECK_ANGLE_LIMIT)
                            {
                                hit = false;
                                angle = 0.0f;
                                up = down = mult = 1.0f;
                                return Vector3D.Zero;
                            }
                            return Vector3D.Transform(forwardVector, Quaternion.CreateFromAxisAngle(rightVector, angle));
                    }
                }
                else
                {
                    switch (Raytracer.Trace(ref tracePosition, ignorePlanet))
                    {
                        case Raytracer.Result.Hit:
                            hit = true;
                            up = down = mult = 1.0f;
                            return Vector3D.Transform(forwardVector, Quaternion.CreateFromAxisAngle(rightVector, angle));

                        case Raytracer.Result.NoHit:
                            up = down = 1.0f;
                            angle += angleDir * mult * HORIZONT_CHECK_ANGLE_STEP;
                            mult = Math.Min(10.0f, mult + 1.0f);
                            if (Math.Abs(angle) > HORIZONT_CHECK_ANGLE_LIMIT)
                            {
                                angle = Math.Min(HORIZONT_CHECK_ANGLE_LIMIT, Math.Max(angle, -HORIZONT_CHECK_ANGLE_LIMIT));
                                angleDir *= -1.0f;
                                mult = 1.0f;
                            }
                            return Vector3D.Zero;
                    }
                }
                return null;
            }
        }

        private static class Guidance
        { // Guidance
            private static Vector3D desiredPosition = new Vector3D();
            private static Vector3D desiredFront = new Vector3D();
            private static Vector3D desiredUp = new Vector3D();
            private static float desiredSpeed = MAX_SPEED;

            public static void Set(Waypoint w)
            {
                desiredPosition = w.stance.position;
                desiredFront = w.stance.forward;
                desiredUp = w.stance.up;
                desiredSpeed = w.maxSpeed;
            }

            public static void Release()
            {
                foreach (IMyGyro gyro in GridBlocks.gyroBlocks)
                {
                    gyro.GyroOverride = false;
                }
                foreach (IMyThrust thruster in GridBlocks.thrusterBlocks)
                {
                    thruster.ThrustOverride = 0;
                }
            }

            public static void Tick()
            {
                Guidance.StanceTick();
                Guidance.GyroTick();
                Guidance.ThrusterTick();
            }

            public static bool Done()
            { // Guidance.Done
                return (Math.Abs(elevation) <= ROTATION_CHECK_TOLERANCE * 2
                    && Math.Abs(azimuth) <= ROTATION_CHECK_TOLERANCE * 2
                    && Math.Abs(roll) <= ROTATION_CHECK_TOLERANCE * 2
                    && pathLen <= DISTANCE_CHECK_TOLERANCE * 2
                    && ConnectorControl.Connect()) || (Math.Abs(elevation) <= ROTATION_CHECK_TOLERANCE
                    && Math.Abs(azimuth) <= ROTATION_CHECK_TOLERANCE
                    && Math.Abs(roll) <= ROTATION_CHECK_TOLERANCE
                    && pathLen <= DISTANCE_CHECK_TOLERANCE);
            }

            private static Vector3D pathNormal, path, aimTarget, upVector, aimVector;
            public static float pathLen;

            private static void StanceTick()
            {
                path = desiredPosition - Situation.position;
                pathLen = (float)path.Length();
                pathNormal = Vector3D.Normalize(path);
                if (desiredFront != Vector3D.Zero)
                {
                    aimTarget = Situation.position + desiredFront * Situation.radius;
                }
                else
                {
                    aimVector = (pathLen > GUIDANCE_MIN_AIM_DISTANCE) ? pathNormal : Situation.forwardVector;
                    if (Situation.inGravity && !Situation.ignoreGravity)
                    {
                        aimTarget = Situation.position + Vector3D.Normalize(Vector3D.ProjectOnPlane(ref aimVector, ref Situation.gravityUpVector)) * Situation.radius;
                    }
                    else
                    {
                        aimTarget = Situation.position + aimVector * Situation.radius;
                    }
                }
                if (Situation.inGravity && !Situation.ignoreGravity)
                {
                    upVector = (desiredUp == Vector3D.Zero) ? Situation.gravityUpVector : desiredUp;
                }
                else
                {
                    upVector = (desiredUp == Vector3D.Zero) ? Vector3D.Cross(aimVector, Situation.leftVector) : desiredUp;
                }
            }

            private static Quaternion invQuat;
            private static Vector3D direction, refVector, worldVector, localVector, realUpVect, realRightVect;
            private static double azimuth, elevation, roll;

            private static void GyroTick()
            {
                if (GridBlocks.gyroBlocks.Count == 0)
                {
                    return;
                }
                direction = Vector3D.Normalize(aimTarget - Situation.position);
                invQuat = Quaternion.Inverse(Quaternion.CreateFromForwardUp(Situation.forwardVector, Situation.upVector));
                refVector = Vector3D.Transform(direction, invQuat);
                Vector3D.GetAzimuthAndElevation(refVector, out azimuth, out elevation);
                realUpVect = Vector3D.ProjectOnPlane(ref upVector, ref direction);
                realUpVect.Normalize();
                realRightVect = Vector3D.Cross(direction, realUpVect);
                realRightVect.Normalize();
                roll = Vector3D.Dot(Situation.upVector, realRightVect);
                worldVector = Vector3.Transform((new Vector3D(elevation, azimuth, roll)), Situation.orientation);

                foreach (IMyGyro gyro in GridBlocks.gyroBlocks)
                {
                    localVector = Vector3.Transform(worldVector, Matrix.Transpose(gyro.WorldMatrix.GetOrientation()));
                    gyro.Pitch = (float)MathHelper.Clamp((-localVector.X * GYRO_GAIN), -GYRO_MAX_ANGULAR_VELOCITY, GYRO_MAX_ANGULAR_VELOCITY);
                    gyro.Yaw = (float)MathHelper.Clamp(((-localVector.Y) * GYRO_GAIN), -GYRO_MAX_ANGULAR_VELOCITY, GYRO_MAX_ANGULAR_VELOCITY);
                    gyro.Roll = (float)MathHelper.Clamp(((-localVector.Z) * GYRO_GAIN), -GYRO_MAX_ANGULAR_VELOCITY, GYRO_MAX_ANGULAR_VELOCITY);
                    gyro.GyroOverride = true;
                }
            }

            private static float forwardChange, upChange, leftChange, applyPower;
            private static Vector3D force, linearVelocity, directVel;
            private static double maxFrc, maxVel;

            private static void ThrusterTick()
            {
                maxFrc = Situation.GetMaxThrust(pathNormal);
                var Ȋ = -110.1f * Situation.mass / maxFrc + 203.3f;
                var ȋ = 2.5 * Situation.mass / maxFrc + 2.9;
                var Ȍ = Math.Min(1.0, Math.Pow((1.0 / Ȋ) * pathLen, 1.0 / ȋ));
                maxVel = Ȍ * Math.Sqrt(2.0f * maxFrc * pathLen / Situation.mass);
                linearVelocity = Situation.linearVelocity / TICK_TIME;
                directVel = Math.Min(desiredSpeed, maxVel) * pathNormal / TICK_TIME;
                force = Situation.mass * (-directVel + linearVelocity) + Situation.mass * Situation.naturalGravity;
                forwardChange = (float)Vector3D.Dot(force, Situation.gridForwardVect);
                upChange = (float)Vector3D.Dot(force, Situation.gridUpVect);
                leftChange = (float)Vector3D.Dot(force, Situation.gridLeftVect);
                foreach (IMyThrust thruster in GridBlocks.thrusterBlocks)
                {
                    if (!thruster.IsWorking)
                    {
                        thruster.ThrustOverridePercentage = 0;
                        continue;
                    }
                    switch (thruster.Orientation.Forward)
                    {
                        case Base6Directions.Direction.Forward:
                            thruster.ThrustOverridePercentage = ((forwardChange < 0) ? IDLE_POWER : (Guidance.Drain(ref forwardChange, thruster.MaxEffectiveThrust)));
                            break;

                        case Base6Directions.Direction.Backward:
                            thruster.ThrustOverridePercentage = ((forwardChange > 0) ? IDLE_POWER : (Guidance.Drain(ref forwardChange, thruster.MaxEffectiveThrust)));
                            break;

                        case Base6Directions.Direction.Up:
                            thruster.ThrustOverridePercentage = ((upChange < 0) ? IDLE_POWER : (Guidance.Drain(ref upChange, thruster.MaxEffectiveThrust)));
                            break;

                        case Base6Directions.Direction.Down:
                            thruster.ThrustOverridePercentage = ((upChange > 0) ? IDLE_POWER : (Guidance.Drain(ref upChange, thruster.MaxEffectiveThrust)));
                            break;

                        case Base6Directions.Direction.Left:
                            thruster.ThrustOverridePercentage = ((leftChange < 0) ? IDLE_POWER : (Guidance.Drain(ref leftChange, thruster.MaxEffectiveThrust)));
                            break;

                        case Base6Directions.Direction.Right:
                            thruster.ThrustOverridePercentage = ((leftChange > 0) ? IDLE_POWER : (Guidance.Drain(ref leftChange, thruster.MaxEffectiveThrust)));
                            break;
                    }
                }
            }

            private static float Drain(ref float remainingPower, float maxEffectiveThrust)
            {
                applyPower = Math.Min(Math.Abs(remainingPower), maxEffectiveThrust);
                remainingPower = (remainingPower > 0.0f) ? (remainingPower - applyPower) : (remainingPower + applyPower);
                return Math.Max(applyPower / maxEffectiveThrust, IDLE_POWER);
            }
        }

        private static class Navigation
        { // Navigation
            public static List<Waypoint> waypoints = new List<Waypoint> { };

            public static string Status()
            {
                if (waypoints.Count == 0)
                {
                    return "";
                }
                return waypoints[0].GetTypeMsg();
            }

            private static Vector3D? horizontDirectionNormal;
            private static Vector3D endTarget, endTargetPath, endTargetNormal, newDirection, newTarget, endTargetRightVector;

            private static void CheckCollision()
            {
                switch (waypoints[0].type)
                {
                    case Waypoint.wpType.CONVERGING:
                        if ((waypoints[0].stance.position - Situation.position).Length() < APPROACH_DISTANCE)
                        {
                            waypoints[0].type = Waypoint.wpType.APPROACHING;
                            waypoints[0].maxSpeed = APPROACHING_SPEED;
                        }
                        goto case Waypoint.wpType.APPROACHING;
                    case Waypoint.wpType.APPROACHING:
                        if ((waypoints[0].stance.position - Situation.position).Length() < COLLISION_DISABLE_RADIUS_MULTIPLIER * Situation.radius)
                        {
                            return;
                        }
                        break;

                    case Waypoint.wpType.NAVIGATING:
                        break;

                    case Waypoint.wpType.FOLLOWING:
                        // is following, this sets the next point
                        if (Leader.Ǵ.ź != Vector3D.Zero)
                        {
                            waypoints[0].stance.position = Leader.Ǵ.ź + Leader.pos.Z * Situation.radius * Leader.Ǵ.ž + Leader.pos.X * Situation.radius * Leader.Ǵ.Ǒ
                                + Leader.pos.Y * Situation.radius * Vector3D.Cross(Leader.Ǵ.Ǒ, Leader.Ǵ.ž)
                                + 2.0 * Ʌ * Vector3D.Dot(Leader.Ǵ.ǒ, Leader.Ǵ.Ǒ) * Leader.Ǵ.Ǒ
                                + 0.5 * Ʌ * Vector3D.Dot(Leader.Ǵ.ǒ, Leader.Ǵ.ž) * Leader.Ǵ.ž;
                            return;
                        }
                        waypoints[0].stance.position = Situation.position;
                        return;

                    default:
                        return;
                }
                endTarget = waypoints[waypoints[0].type == Waypoint.wpType.NAVIGATING ? 1 : 0].stance.position;
                endTargetPath = endTarget - Situation.position;
                endTargetNormal = Vector3D.Normalize(endTargetPath);
                endTargetRightVector = Vector3D.Normalize(Vector3D.Cross(endTargetNormal, Situation.gravityUpVector));
                horizontDirectionNormal = Horizont.ScanHorizont((float)endTargetPath.Length(), endTargetNormal, endTargetRightVector);
                if (!horizontDirectionNormal.HasValue)
                {
                    return;
                }
                if (Vector3D.IsZero(horizontDirectionNormal.Value))
                {
                    if (waypoints[0].type == Waypoint.wpType.NAVIGATING)
                    {
                        waypoints.RemoveAt(0);
                    }
                    return;
                }
                newDirection = Vector3D.Transform(horizontDirectionNormal.Value, Quaternion.CreateFromAxisAngle(endTargetRightVector, COLLISION_CORRECTION_ANGLE));
                newTarget = Situation.position + Math.Min(HORIZONT_CHECK_DISTANCE, (Situation.position - waypoints.Last().stance.position).Length()) * newDirection;
                if (waypoints[0].type == Waypoint.wpType.NAVIGATING)
                {
                    waypoints[0].stance.position = newTarget;
                }
                else
                { // inserts a waypoint
                    waypoints.Insert(0, new Waypoint(new Stance(newTarget, Vector3D.Zero, Vector3D.Zero), MAX_SPEED, Waypoint.wpType.NAVIGATING));
                }
            }

            public static void Tick()
            {
                if (waypoints.Count == 0)
                {
                    return;
                }
                Situation.RefreshParameters();
                CheckCollision();
                Guidance.Set(waypoints.ElementAt(0));
                Guidance.Tick();
                if (waypoints[0].type == Waypoint.wpType.HOPPING)
                {
                    if ((waypoints[0].stance.position - Situation.position).Length() < APPROACH_DISTANCE)
                    {
                        waypoints.Clear();
                        Guidance.Release();
                    }
                }
                if (Guidance.Done())
                {
                    if (waypoints[0].type == Waypoint.wpType.FOLLOWING)
                    {
                        return; // needs to be allowed
                    }
                    waypoints.RemoveAt(0);
                    if (waypoints.Count != 0)
                    {
                        return;
                    }
                    Guidance.Release();
                }
            }

            public static void AddWaypoint(Waypoint wp)
            {
                waypoints.Insert(0, wp);
            }

            public static void AddWaypoint(Stance s, float m, Waypoint.wpType wt)
            {
                AddWaypoint(new Waypoint(s, m, wt));
            }

            public static void AddWaypoint(Vector3D p, Vector3D f, Vector3D u, float travelSpeed, Waypoint.wpType wt)
            {
                AddWaypoint(new Stance(p, f, u), travelSpeed, wt);
            }

            public static void Stop()
            {
                Guidance.Release();
                waypoints.Clear();
            }

            public static bool Done()
            {
                return waypoints.Count == 0;
            }
        }

        private static class Leader
        { // Leader/Follower
            public static ǐ Ǵ;
            public static Vector3D pos;
            private static ǐ Ƕ;
            private static string command = "";
            private static double Ĕ;

            public static void ProcessLeaderMsg(string str)
            {
                if (!Block.GetProperty(GridBlocks.masterProgrammableBlock.EntityId, "Follow", ref command))
                {
                    return;
                }
                Serializer.InitUnpack(str);
                Ƕ = Serializer.UnpackSomething();
                if (Ƕ.ö != command)
                {
                    return;
                }
                Ǵ = Ƕ;
                if (Block.GetProperty(GridBlocks.masterProgrammableBlock.EntityId, "FollowFront", ref command) && double.TryParse(command, out Ĕ))
                {
                    pos.X = Ĕ;
                }
                else
                {
                    pos.X = 10.0;
                }
                if (Block.GetProperty(GridBlocks.masterProgrammableBlock.EntityId, "FollowUp", ref command) && double.TryParse(command, out Ĕ))
                {
                    pos.Z = Ĕ;
                }
                else
                {
                    pos.Z = 10.0;
                }
                if (Block.GetProperty(GridBlocks.masterProgrammableBlock.EntityId, "FollowRight", ref command) && double.TryParse(command, out Ĕ))
                {
                    pos.Y = Ĕ;
                }
                else
                {
                    pos.Y = 10.0;
                }
            }

            public static void Advertise(Program p)
            {
                if (!Block.HasProperty(GridBlocks.masterProgrammableBlock.EntityId, "LEADER"))
                {
                    return;
                }
                if (RemoteControl.block == null)
                {
                    Logger.Err("No Remote Control");
                    return;
                }
                Ƕ.ź = RemoteControl.block.CenterOfMass;
                if (!Block.GetProperty(GridBlocks.masterProgrammableBlock.EntityId, "Name", ref command))
                {
                    command = GridBlocks.masterProgrammableBlock.CubeGrid.CustomName;
                }
                Ƕ.ö = command;
                Ƕ.Ǔ = GridBlocks.masterProgrammableBlock.CubeGrid.WorldVolume.Radius;
                Ƕ.ǒ = RemoteControl.block.GetShipVelocities().LinearVelocity;
                Ƕ.ž = RemoteControl.block.WorldMatrix.Up;
                Ƕ.Ǒ = RemoteControl.block.WorldMatrix.Forward;
                Serializer.InitPack();
                Serializer.Pack(Ƕ);
                p.IGC.SendBroadcastMessage<string>(LEADER_TAG, Serializer.serialized);
            }
        }

        private static class Commander
        { // Commander
            public static bool active = false;
            public static Dock currentDock;
            public enum Mode
            {
                SINGLE, LIST, LOOP
            };

            public static Mode mode = Mode.SINGLE;
            public static long idleStart = long.MaxValue;
            public static long waitTime = TimeSpan.FromSeconds(10.0).Ticks;

            public static void PilotDoneConflict()
            {
                idleStart = DateTime.Now.Ticks;
            }

            public static void PilotDone()
            {
                active = true;
                currentDock = null;
            }

            public static void Activate(Dock dock)
            {
                active = true;
                currentDock = dock;
                Logistics.RechargeBatteries(false);
                Logistics.Dampeners(true);
            }

            public static void Activate()
            {
                active = false;
                currentDock = null;
            }

            private static bool chargeDone;
            private static bool cargoDone;

            public static void Tick()
            {
                //û.é("in Commander.Tick");
                if (!active || Pilot.running)
                {
                    return;
                }
                if (mode == Mode.SINGLE)
                {
                    Activate();
                    return;
                }
                if (currentDock != null && currentDock.job != Dock.JobType.HOP)
                {
                    if (currentDock.job == Dock.JobType.NONE)
                    {
                        if (DateTime.Now.Ticks - idleStart < waitTime)
                        {
                            return;
                        }
                    }
                    else
                    {
                        if (ConnectorControl.Connected() == null && currentDock.gridName != "Manual")
                        {
                            return;
                        }
                        cargoDone = true;
                        switch (currentDock.job)
                        {
                            case Dock.JobType.LOAD:
                            case Dock.JobType.CHARGE_LOAD:
                                if (!Logistics.CargoFull())
                                {
                                    cargoDone = false;
                                }
                                break;

                            case Dock.JobType.UNLOAD:
                            case Dock.JobType.CHARGE_UNLOAD:
                                if (!Logistics.CargoEmpty())
                                {
                                    Logistics.ChargeFull(true);
                                    cargoDone = false;
                                    break;
                                }
                                Logistics.ChargeFull(false);
                                break;
                        }
                        chargeDone = true;
                        switch (currentDock.job)
                        {
                            case Dock.JobType.CHARGE:
                            case Dock.JobType.CHARGE_LOAD:
                            case Dock.JobType.CHARGE_UNLOAD:
                                if (!Logistics.ChargeFull())
                                {
                                    Logistics.RechargeBatteries(true);
                                    chargeDone = false;
                                    return;
                                }
                                Logistics.RechargeBatteries(false);
                                break;

                            case Dock.JobType.DISCHARGE:
                                if (!Logistics.Charge())
                                {
                                    Logistics.DischargeBatteries(true);
                                    chargeDone = false;
                                    return;
                                }
                                Logistics.DischargeBatteries(false);
                                break;
                        }
                        if (!cargoDone || !chargeDone)
                        {
                            return;
                        }
                    }
                }
                DockData.NAVScreenHandle(Pannels.ScreenAction.Next);
                if (mode == Mode.LIST && DockData.selectedDockNAV == 0)
                {
                    Activate();
                    Logger.Info("Dock list finished, stopping autopilot.");
                    return;
                }
                if (currentDock == null)
                {
                    Logger.Info("Just a waypoint, navigating to next dock.");
                }
                else
                {
                    switch (currentDock.job)
                    {
                        case Dock.JobType.NONE:
                            Logger.Info("Wait time expired, resuming navigation.");
                            break;

                        case Dock.JobType.LOAD:
                            Logger.Info("Cargo loaded, resuming navigation.");
                            break;

                        case Dock.JobType.UNLOAD:
                            Logger.Info("Cargo unloaded, resuming navigation.");
                            break;

                        case Dock.JobType.CHARGE:
                            Logger.Info("Charged, resuming navigation.");
                            break;

                        case Dock.JobType.CHARGE_LOAD:
                            Logger.Info("Charged and cargo loaded, resuming navigation.");
                            break;

                        case Dock.JobType.CHARGE_UNLOAD:
                            Logger.Info("Cargo unloaded, resuming navigation.");
                            break;

                        case Dock.JobType.HOP:
                            Logger.Info("Hopping.");
                            break;

                        case Dock.JobType.DISCHARGE:
                            Logger.Info("Charge low, resuming navitation.");
                            break;
                    }
                }
                Pilot.Start();
            }

            private static string retStr;
            private static bool match;
            private static string myName;
            private static List<KeyValuePair<NavCmd, Dock>> found = new List<KeyValuePair<NavCmd, Dock>> { };
            private static List<NavCmd> notFound = new List<NavCmd> { };
            private static List<NavCmd> ȷ = new List<NavCmd> { };
            private static string command;

            public static void ProcessCmd(Program p, string cmd)
            { // Program
                Serializer.InitUnpack(cmd);
                retStr = ExecuteCmd(Serializer.UnpackShipCommand());
                if (retStr == "")
                {
                    return;
                }
                p.IGC.SendBroadcastMessage<string>(CMD_RES_TAG, retStr);
            }

            public static string ExecuteCmd(ShipCommand shipCommand)
            {
                if (!Block.GetProperty(GridBlocks.masterProgrammableBlock.EntityId, "Name", ref myName))
                {
                    myName = GridBlocks.masterProgrammableBlock.CubeGrid.CustomName;
                }
                if (shipCommand.ShipName != myName)
                {
                    return "";
                }
                if (shipCommand.Command < 0 || shipCommand.Command > Terminal.COMMANDS.Count - 1)
                {
                    return "Received a command that does not exist: " + shipCommand;
                }
                Logger.Info("Remote command received.");
                command = Terminal.COMMANDS[shipCommand.Command];
                if (command.Contains("start"))
                {
                    Pilot.Start();
                    return "Start success.";
                }
                else if (command.Contains("stop"))
                {
                    Pilot.Stop();
                    return "Stop success.";
                }
                found.Clear();
                notFound.Clear();
                foreach (NavCmd nc in shipCommand.navCmds)
                {
                    match = false;
                    foreach (Dock d in DockData.docks.ToArray())
                    {
                        if (nc.GPSPosition == Vector3D.Zero)
                        {
                            if (nc.Connector == d.blockName)
                            {
                                if (nc.Grid == "" || nc.Grid == d.gridName)
                                {
                                    found.Add(new KeyValuePair<NavCmd, Dock>(nc, d));
                                    match = true;
                                    break;
                                }
                            }
                        }
                        else
                        {
                            if (d.gridName == "Manual" && d.stance.position == nc.GPSPosition)
                            {
                                found.Add(new KeyValuePair<NavCmd, Dock>(nc, d));
                                match = true;
                                break;
                            }
                        }
                    }
                    if (!match)
                    {
                        if (nc.GPSPosition != Vector3D.Zero)
                        {
                            found.Add(new KeyValuePair<NavCmd, Dock>(nc, DockData.AddDock(nc.GPSName, nc.GPSPosition)));
                        }
                        else
                        {
                            notFound.Add(nc);
                        }
                    }
                }
                if (notFound.Count != 0)
                {
                    return "Not found: " + notFound.Count.ToString();
                }
                Pilot.Stop();
                DockData.selectedDocks.Clear();
                DockData.selectedDockNAV = 0;
                foreach (KeyValuePair<NavCmd, Dock> kp in found)
                {
                    kp.Value.job = kp.Key.Action;
                    DockData.selectedDocks.Add(kp.Value);
                }
                DockData.BalanceDisplays();
                if (command.Contains("step"))
                {
                    SetMode(Mode.SINGLE);
                }
                else if (command.Contains("run"))
                {
                    SetMode(Mode.LIST);
                }
                else if (command.Contains("loop"))
                {
                    SetMode(Mode.LOOP);
                }
                if (!command.Contains("conf"))
                {
                    Pilot.Start();
                }
                return "Command executed";
            }

            private static string newCustomName;
            private static void SetMode(Mode newMode)
            {
                mode = newMode;
                newCustomName = GridBlocks.masterProgrammableBlock.CustomName;
                if (newMode == Mode.LIST)
                {
                    newCustomName = newCustomName.Replace(" LOOP", "");
                    newCustomName = newCustomName.Replace("[" + TAG, "[" + TAG + " LIST");
                    Block.UpdateProperty(GridBlocks.masterProgrammableBlock.EntityId, "LIST", "");
                    Block.RemoveProperty(GridBlocks.masterProgrammableBlock.EntityId, "LOOP");
                }
                else if (newMode == Mode.LOOP)
                {
                    newCustomName = newCustomName.Replace(" LIST", "");
                    newCustomName = newCustomName.Replace("[" + TAG, "[" + TAG + " LOOP");
                    Block.UpdateProperty(GridBlocks.masterProgrammableBlock.EntityId, "LOOP", "");
                    Block.RemoveProperty(GridBlocks.masterProgrammableBlock.EntityId, "LIST");
                }
                else
                {
                    newCustomName = newCustomName.Replace(" LIST", "");
                    newCustomName = newCustomName.Replace(" LOOP", "");
                    Block.RemoveProperty(GridBlocks.masterProgrammableBlock.EntityId, "LOOP");
                    Block.RemoveProperty(GridBlocks.masterProgrammableBlock.EntityId, "LIST");
                }
                GridBlocks.masterProgrammableBlock.CustomName = newCustomName;
            }
        }

        private static class Logistics
        { // Logistics
            private static string valStr;
            private static float valFloat;

            public static void Dampeners(bool enable)
            {
                RemoteControl.block.DampenersOverride = enable;
            }

            private static List<IMyGasTank> tempTanks = new List<IMyGasTank>();

            public static bool CargoFull()
            {
                tempTanks.Clear();
                foreach (IMyGasTank tankBlock in GridBlocks.tankBlocks)
                {
                    if (!Block.HasProperty(tankBlock.EntityId, "CARGO"))
                    {
                        Logger.Info("is Cargo - continuing");
                        continue;
                    }
                    tempTanks.Add(tankBlock);
                    tankBlock.Stockpile = true;
                }
                foreach (IMyGasTank tankBlock in tempTanks)
                {
                    valFloat = 95.0f;
                    if (Block.GetProperty(tankBlock.EntityId, "Full", ref valStr))
                    {
                        Logger.Info("tank Full");
                        if (!float.TryParse(valStr, out valFloat))
                        {
                            valFloat = 95.0f;
                        }
                    }
                    if (tankBlock.FilledRatio < valFloat / 100.0f)
                    {
                        Logger.Info("tank Full calcs returning false");
                        return false;
                    }
                }
                foreach (IMyCargoContainer cargoBlock in GridBlocks.cargoBlocks)
                {
                    Logger.Info("Container " + cargoBlock.CustomName);
                    valFloat = 90f;
                    if (Block.GetProperty(cargoBlock.EntityId, "Full", ref valStr))
                    {
                        Logger.Info("is Full ");
                        if (!float.TryParse(valStr, out valFloat))
                        {
                            valFloat = 90f;
                        }
                    }
                    IMyInventory inventory = cargoBlock.GetInventory();
                    Logger.Info("inventory.CurrentVolume.RawValue = " + inventory.CurrentVolume.RawValue);
                    Logger.Info("inventory.MaxVolume.RawValue * ē / 100.0f = " + inventory.CurrentVolume.RawValue);
                    if (inventory.CurrentVolume.RawValue < (inventory.MaxVolume.RawValue * valFloat / 100.0f))
                    {
                        return false;
                    }
                }
                return true;
            }

            // UP TO HERE
            public static bool CargoEmpty()
            {
                tempTanks.Clear();
                foreach (IMyGasTank tankBlock in GridBlocks.tankBlocks)
                {
                    if (!Block.HasProperty(tankBlock.EntityId, "CARGO"))
                    {
                        continue;
                    }
                    tempTanks.Add(tankBlock);
                    tankBlock.Stockpile = false;
                }
                foreach (IMyGasTank tankBlock in tempTanks)
                {
                    valFloat = 0.0f;
                    if (Block.GetProperty(tankBlock.EntityId, "Empty", ref valStr))
                    {
                        if (!float.TryParse(valStr, out valFloat))
                        {
                            valFloat = 0.0f;
                        }
                    }
                    if (tankBlock.FilledRatio > valFloat / 100.0f)
                    {
                        return false;
                    }
                }
                foreach (IMyCargoContainer cargoBlock in GridBlocks.cargoBlocks)
                {
                    valFloat = 0.0f;
                    if (Block.GetProperty(cargoBlock.EntityId, "Empty", ref valStr))
                    {
                        if (!float.TryParse(valStr, out valFloat))
                        {
                            valFloat = 0.0f;
                        }
                    }
                    IMyInventory inventory = cargoBlock.GetInventory();
                    if (inventory.CurrentVolume.RawValue > (inventory.MaxVolume.RawValue * valFloat / 100.0f))
                    {
                        return false;
                    }
                }
                return true;
            }

            public static void ChargeFull(bool chargeState)
            {
                foreach (IMyGasTank tankBlock in GridBlocks.tankBlocks)
                {
                    if (Block.HasProperty(tankBlock.EntityId, "CARGO"))
                    {
                        foreach (IMyGasTank chargeTankBlock in GridBlocks.chargeTankBlocks)
                        {
                            chargeTankBlock.Stockpile = chargeState;
                        }
                        return;
                    }
                }
            }

            public static bool ChargeFull()
            {
                foreach (IMyGasTank tankBlock in GridBlocks.tankBlocks)
                {
                    if (Block.HasProperty(tankBlock.EntityId, "CARGO"))
                    {
                        continue;
                    }
                    valFloat = 95.0f;
                    tankBlock.Stockpile = true;
                    if (Block.GetProperty(tankBlock.EntityId, "Full", ref valStr))
                    {
                        if (!float.TryParse(valStr, out valFloat))
                        {
                            valFloat = 95.0f;
                        }
                    }
                    if (tankBlock.FilledRatio < valFloat / 100.0f)
                    {
                        return false;
                    }
                }
                foreach (IMyBatteryBlock batteryBlock in GridBlocks.batteryBlocks)
                {
                    valFloat = 95f;
                    if (Block.GetProperty(batteryBlock.EntityId, "Full", ref valStr))
                    {
                        if (!float.TryParse(valStr, out valFloat))
                        {
                            valFloat = 95f;
                        }
                    }
                    if (batteryBlock.CurrentStoredPower < (batteryBlock.MaxStoredPower * valFloat / 100.0f))
                    {
                        return false;
                    }
                }
                Logger.Info("Everything is charged!");
                return true;
            }

            public static bool Charge()
            {
                foreach (IMyBatteryBlock batteryBlock in GridBlocks.batteryBlocks)
                {
                    valFloat = 25.0f;
                    if (Block.GetProperty(batteryBlock.EntityId, "Empty", ref valStr))
                    {
                        if (!float.TryParse(valStr, out valFloat))
                        {
                            valFloat = 25.0f;
                        }
                    }
                    if (batteryBlock.CurrentStoredPower < (batteryBlock.MaxStoredPower * valFloat / 100.0f))
                    {
                        return true;
                    }
                }
                return false;
            }

            private static bool forceRecharge, forceDischarge;
            public static void RechargeBatteries(bool enable)
            {
                foreach (IMyBatteryBlock batteryBlock in GridBlocks.batteryBlocks)
                {
                    forceRecharge = Block.HasProperty(batteryBlock.EntityId, "FORCE");
                    batteryBlock.ChargeMode = enable && forceRecharge ? ChargeMode.Recharge : ChargeMode.Auto;
                }
                foreach (IMyGasTank tankBlock in GridBlocks.tankBlocks)
                {
                    if (Block.HasProperty(tankBlock.EntityId, "CARGO"))
                    {
                        continue;
                    }
                    forceRecharge = Block.HasProperty(tankBlock.EntityId, "FORCE");
                    tankBlock.Stockpile = enable && forceRecharge;
                }
            }

            public static void DischargeBatteries(bool enable)
            {
                foreach (IMyBatteryBlock batteryBlock in GridBlocks.batteryBlocks)
                {
                    forceDischarge = Block.HasProperty(batteryBlock.EntityId, "FORCE");
                    batteryBlock.ChargeMode = enable && forceDischarge ? ChargeMode.Discharge : ChargeMode.Auto;
                }
                foreach (IMyBatteryBlock chargeBatteryBlocks in GridBlocks.swapChargeBatteryBlocks)
                {
                    chargeBatteryBlocks.ChargeMode = enable ? ChargeMode.Recharge : ChargeMode.Auto;
                }
            }
        }

        private static class Pilot
        { // Pilot
            public static bool running = false;
            public static List<Dock> dock = new List<Dock>();
            public static void Tick()
            {
                if (!running)
                {
                    return;
                }
                if (!RemoteControl.Present())
                {
                    if (!ErrorState.Get(ErrorState.Type.NoRemoteController))
                    {
                        Logger.Err("No Remote Control!");
                    }
                    ErrorState.Set(ErrorState.Type.NoRemoteController);
                    Stop();
                    return;
                }
                if (Navigation.Done())
                {
                    if (dock.Count != 0 && dock[0].gridEntityId != 0)
                    {
                        if (dock[0].job == Dock.JobType.HOP)
                        {
                            dock.Clear();
                            Logger.Info("Hop successful!");
                            Commander.PilotDoneConflict();
                            running = false;
                            return;
                        }
                        CalculateApproach();
                        dock.Clear();
                        return;
                    }
                    Logger.Info("Navigation successful!");
                    Signal.Send(Signal.SignalType.NAVIGATION);
                    Commander.PilotDoneConflict();
                    ConnectorControl.AttemptConnect();
                    running = false;
                    return;
                }
                Navigation.Tick();
            }

            private static Quaternion qInitialInverse, qFinal, qDiff;
            private static Vector3D connectorToCenter, rotatedConnectorToCenter, newUp, newForward, up, referenceUp, direction, balancedDirection;
            private static IMyShipConnector connector;
            private static bool revConnector;
            private static float connectorDistance;
            private static void CalculateApproach()
            {
                connector = ConnectorControl.GetConnector(dock[0]);
                if (connector == null)
                {
                    Logger.Warn("No connectors available!");
                    return;
                }
                Situation.RefreshParameters();
                connectorToCenter = Situation.position - connector.GetPosition();
                if (Math.Abs(Vector3D.Dot(dock[0].stance.forward, Situation.gravityUpVector)) < 0.5f)
                {
                    up = Situation.gravityUpVector;
                    referenceUp = connector.WorldMatrix.GetDirectionVector(connector.WorldMatrix.GetClosestDirection(up));
                    referenceUp = (referenceUp == connector.WorldMatrix.Forward || referenceUp == connector.WorldMatrix.Backward) ? connector.WorldMatrix.Up : referenceUp;
                }
                else
                {
                    up = dock[0].stance.up;
                    referenceUp = connector.WorldMatrix.Up;
                }
                revConnector = Block.HasProperty(connector.EntityId, "REV");
                qInitialInverse = Quaternion.Inverse(Quaternion.CreateFromForwardUp(revConnector ? connector.WorldMatrix.Backward : connector.WorldMatrix.Forward, referenceUp));
                qFinal = Quaternion.CreateFromForwardUp(-dock[0].stance.forward, up);
                qDiff = qFinal * qInitialInverse;
                rotatedConnectorToCenter = Vector3D.Transform(connectorToCenter, qDiff);
                newForward = Vector3D.Transform(RemoteControl.block.WorldMatrix.Forward, qDiff);
                newUp = Vector3D.Transform(RemoteControl.block.WorldMatrix.Up, qDiff);
                connectorDistance = (dock[0].cubeSize == VRage.Game.MyCubeSize.Large) ? 2.6f / 2.0f : 0.5f;
                connectorDistance += (connector.CubeGrid.GridSizeEnum == VRage.Game.MyCubeSize.Large) ? 2.6f / 2.0f : 0.5f;
                newPos = dock[0].stance.position + rotatedConnectorToCenter + (connectorDistance * dock[0].stance.forward);
                Navigation.AddWaypoint(newPos, newForward, newUp, DOCKING_SPEED, Waypoint.wpType.DOCKING);
                newPos = dock[0].stance.position + rotatedConnectorToCenter + ((DOCK_DISTANCE + connectorDistance) * dock[0].stance.forward);
                Navigation.AddWaypoint(newPos, newForward, newUp, TAXIING_SPEED, Waypoint.wpType.TAXIING);
                dock[0].approachPath.Reverse();
                foreach (VectorPath Ε in dock[0].approachPath)
                {
                    newPos = Ε.position + (Ε.direction * (TAXIING_PANEL_DISTANCE + Situation.radius));
                    Navigation.AddWaypoint(newPos, Vector3D.Zero, Vector3D.Zero, TAXIING_SPEED, Waypoint.wpType.TAXIING);
                }
                dock[0].approachPath.Reverse();
            }

            private static Vector3D newPos, undockPos;
            private static Dock disconnectDock;
            private static Waypoint.wpType wpType;
            private static void SetEndStance(Dock dock)
            {
                Situation.RefreshParameters();
                wpType = (dock.job == Dock.JobType.HOP) ? Waypoint.wpType.HOPPING : Waypoint.wpType.CONVERGING;
                if (dock.blockEntityId == 0)
                {
                    Navigation.AddWaypoint(dock.stance, MAX_SPEED, Waypoint.wpType.ALIGNING);
                    Navigation.AddWaypoint(dock.stance.position, Vector3D.Zero, Vector3D.Zero, MAX_SPEED, wpType);
                    newPos = dock.stance.position;
                }
                else
                {
                    if (dock.approachPath.Count == 0)
                    {
                        newPos = dock.stance.position + ((TAXIING_DISTANCE + Situation.radius) * dock.stance.forward);
                    }
                    else
                    {
                        newPos = dock.approachPath[0].position + ((TAXIING_DISTANCE + Situation.radius) * dock.approachPath[0].direction);
                    }
                    Navigation.AddWaypoint(newPos, Vector3D.Zero, Vector3D.Zero, MAX_SPEED, wpType);
                }
                if (Situation.linearVelocity.Length() >= 2.0f)
                {
                    return;
                }
                disconnectDock = ConnectorControl.DisconnectAndTaxiData();
                direction = Vector3D.Normalize(newPos - Situation.position);
                balancedDirection = Vector3D.ProjectOnPlane(ref direction, ref Situation.gravityUpVector);
                if (disconnectDock == null)
                {
                    Navigation.AddWaypoint(Situation.position, balancedDirection, Situation.gravityUpVector, MAX_SPEED, Waypoint.wpType.ALIGNING);
                    return;
                }
                if (disconnectDock.approachPath.Count > 0)
                {
                    foreach (VectorPath vp in disconnectDock.approachPath)
                    {
                        newPos = vp.position + (vp.direction * (TAXIING_PANEL_DISTANCE + Situation.radius));
                        Navigation.AddWaypoint(newPos, Vector3D.Zero, Vector3D.Zero, TAXIING_SPEED, Waypoint.wpType.TAXIING);
                    }
                }
                undockPos = disconnectDock.stance.forward;
                undockPos *= (Situation.radius + UNDOCK_DISTANCE);
                undockPos += Situation.position;
                Navigation.AddWaypoint(undockPos, balancedDirection, Situation.gravityUpVector, DOCKING_SPEED, Waypoint.wpType.ALIGNING);
                Navigation.AddWaypoint(undockPos, Situation.forwardVector, Situation.upVector, DOCKING_SPEED, Waypoint.wpType.UNDOCKING);
            }

            public static void Start()
            {
                Start(DockData.GetSelected());
            }

            public static void Start(Dock d)
            {
                if (d == null)
                {
                    return;
                }
                if (!RemoteControl.PresentOrLog())
                {
                    return;
                }
                Stop();
                Logger.Info("Navigating to " + "[" + d.gridName + "] " + d.blockName);
                dock.Add(d);
                SetEndStance(d);
                running = true;
                Commander.Activate(d);
                Signal.Send(Signal.SignalType.START);
            }

            public static void Follow()
            {
                Stance stance = new Stance(new Vector3D(1, 1, 1), Vector3D.Zero, Vector3D.Zero);
                Waypoint wp = new Waypoint(stance, MAX_SPEED, Waypoint.wpType.FOLLOWING);
                Follow(wp);
            }

            public static void Follow(Waypoint wp)
            {
                if (!RemoteControl.PresentOrLog())
                {
                    return;
                }
                if (wp.stance.position == Vector3D.Zero)
                {
                    Logger.Err("Invalid GPS format!");
                    return;
                }
                Stop();
                Logger.Info("Navigating to coordinates");
                Navigation.AddWaypoint(wp);
                running = true;
                Commander.PilotDone();
            }

            public static void Stop()
            {
                Navigation.Stop();
                dock.Clear();
                running = false;
                Commander.Activate();
            }

            public static void Toggle()
            {
                if (running)
                {
                    Stop();
                    return;
                }
                Start();
            }
        }

        private IMyBroadcastListener listener;
        private IMyBroadcastListener cmdListener;
        private IMyBroadcastListener cmdResListener;
        private IMyBroadcastListener leaderListener;
        private bool clearStorage = false;
        private ShipCommand2 shipCommand = new ShipCommand2();
        private Program()
        {
            try
            {
                if (this.Load())
                {
                    Logger.Info("Loaded previous session");
                }
            }
            catch (Exception exception)
            {
                Logger.Warn("Unable to load previous session: " + exception.Message);
                Storage = "";
            }
            Runtime.UpdateFrequency = UpdateFrequency.Update100 | UpdateFrequency.Update10 | UpdateFrequency.Once;
            listener = IGC.RegisterBroadcastListener(TAG);
            listener.SetMessageCallback(TAG);
            cmdListener = IGC.RegisterBroadcastListener(CMD_TAG);
            cmdListener.SetMessageCallback(CMD_TAG);
            cmdResListener = IGC.RegisterBroadcastListener(CMD_RES_TAG);
            cmdResListener.SetMessageCallback(CMD_RES_TAG);
            leaderListener = IGC.RegisterBroadcastListener(LEADER_TAG);
            leaderListener.SetMessageCallback(LEADER_TAG);
        }

        private bool Load()
        {
            if (Storage.Length != 0)
            {
                Logger.Info("Loading session size: " + Storage.Length);
                if (StorageData.Load(Storage))
                {
                    return true;
                }
                Logger.Warn("Unable to Load previous session due to different version");
            }
            return false;
        }

        private void Save()
        {
            try
            {
                string str = clearStorage ? "" : StorageData.Save();
                Logger.Info("Saving session size: " + str.Length);
                Storage = str;
            }
            catch (Exception e)
            {
                Logger.Info("Failed to save: " + e.Message);
            }
        }

        private static class StorageData
        { // StorageData
            public static string Save()
            {
                try
                {
                    Serializer.InitPack();
                    Serializer.Pack(STORAGE_VERSION);
                    Serializer.Pack(DockData.currentDockCount);
                    Serializer.Pack(DockData.docks);
                    Serializer.Pack(Pilot.dock);
                }
                catch (Exception e)
                {
                    Logger.Info("Error1");
                    throw e;
                }
                try
                {
                    List<int> selected = new List<int>();
                    foreach (Dock d in DockData.selectedDocks)
                    {
                        selected.Add(DockData.docks.IndexOf(d));
                    }
                    Serializer.Pack(selected);
                    Serializer.Pack(Horizont.angle);
                    Serializer.Pack(Horizont.hit);
                    Serializer.Pack(DockData.selectedDockNAV);
                    Serializer.Pack(DockData.selectedDockCONF);
                    Serializer.Pack(DockData.selectedTopNAV);
                }
                catch (Exception e) {
                    Logger.Info("Error2");
                    throw e;
                }
                try
                {
                    Serializer.Pack(DockData.selectedTopCONF);
                    Serializer.Pack(Pilot.running);
                    Serializer.Pack(Navigation.waypoints);
                    Serializer.Pack(Commander.active);
                    if (Commander.active)
                    {
                        Serializer.Pack(Commander.currentDock);
                    }
                    Serializer.Pack(Commander.mode);
                }
                catch (Exception e) {
                    Logger.Info("Error3");
                    throw e;
                }
                return Serializer.serialized;
            }

            public static bool Load(string str)
            {
                Serializer.InitUnpack(str);
                if (STORAGE_VERSION != Serializer.UnpackString())
                {
                    return false;
                }
                DockData.currentDockCount = Serializer.UnpackInt();
                DockData.docks = Serializer.UnpackListDock();
                Pilot.dock = Serializer.UnpackListDock();
                List<int> selected = Serializer.UnpackListInt();
                DockData.selectedDocks.Clear();
                foreach (int i in selected)
                {
                    DockData.selectedDocks.Add(DockData.docks[i]);
                }
                DockData.dynamic.Clear();
                foreach (Dock d in DockData.docks)
                {
                    if (d.gridEntityId == 0)
                    {
                        continue;
                    }
                    DockData.dynamic[d.blockEntityId] = d;
                    if (Pilot.dock.Count != 0 && Pilot.dock[0].blockEntityId == d.blockEntityId)
                    {
                        Pilot.dock.Clear();
                        Pilot.dock.Add(d);
                    }
                }
                Horizont.angle = Serializer.UnpackFloat();
                Horizont.hit = Serializer.UnpackBool();
                DockData.selectedDockNAV = Serializer.UnpackInt();
                DockData.selectedDockCONF = Serializer.UnpackInt();
                DockData.selectedTopNAV = Serializer.UnpackInt();
                DockData.selectedTopCONF = Serializer.UnpackInt();
                Pilot.running = Serializer.UnpackBool();
                Navigation.waypoints = Serializer.UnpackListWaypoint();
                if (Serializer.deserialized.Count == 0)
                {
                    return true;
                }
                Commander.active = Serializer.UnpackBool();
                if (Commander.active)
                {
                    Commander.currentDock = Serializer.UnpackDock();
                }
                Commander.mode = Serializer.UnpackCommanderMode();
                return true;
            }
        }

        private void HandleCommand(ref string command)
        {
            string[] parts = command.Trim().Split(' ');
            parts.DefaultIfEmpty("");
            string arg0 = parts.ElementAtOrDefault(0).ToUpper();
            string arg1 = parts.ElementAtOrDefault(1);
            arg1 = arg1 ?? "";
            try
            {
                switch (arg0)
                {
                    case "PREV":
                        Pannels.ScreenHandle(Pannels.ScreenAction.Prev);
                        break;
                    case "NEXT":
                        Pannels.ScreenHandle(Pannels.ScreenAction.Next);
                        break;
                    case "SELECT":
                        Pannels.ScreenHandle(Pannels.ScreenAction.Select);
                        break;
                    case "ADD":
                        switch (arg1.ToUpper())
                        {
                            case "STANCE":
                                Pannels.ScreenHandle(Pannels.ScreenAction.AddStance, String.Join(" ", parts.Skip(2).ToArray()));
                                break;
                            case "ORBIT":
                                Pannels.ScreenHandle(Pannels.ScreenAction.AddOrbit);
                                break; 
                            default:
                                Pannels.ScreenHandle(Pannels.ScreenAction.Add, String.Join(" ", parts.Skip(1).ToArray()));
                                break;
                        }
                        break;
                    case "REMOVE":
                        Pannels.ScreenHandle(Pannels.ScreenAction.Rem);
                        break;
                    case "SCREEN":
                        Pannels.NextScreen();
                        break;
                    case "FOLLOW":
                        Pilot.Follow();
                        break;
                    case "START":
                        switch (arg1.ToUpper())
                        {
                            case "PREV":
                                Signal.Clear();
                                DockData.NAVScreenHandle(Pannels.ScreenAction.Prev);
                                Pilot.Start();
                                break;
                            case "NEXT":
                                Signal.Clear();
                                DockData.NAVScreenHandle(Pannels.ScreenAction.Next);
                                Pilot.Start();
                                break;
                            case "":
                                Signal.Clear();
                                Pilot.Start();
                                break;
                            default:
                                Signal.Clear();
                                Pilot.Follow(Waypoint.FromString(String.Join(" ", parts.Skip(1).ToArray())));
                                break;
                        }
                        break;

                    case "GO":
                        switch (arg1.ToUpper())
                        {
                            case "":
                                Logger.Err("There is no where to GO.");
                                break;
                            default:
                                Signal.Clear();
                                Pilot.Start(DockData.GetDock(String.Join(" ", parts.Skip(1).ToArray())));
                                break;
                        }
                        break;

                    case "TOGGLE":
                        Pilot.Toggle();
                        Signal.Clear();
                        break;
                    case "STOP":
                        Pilot.Stop();
                        Signal.Clear();
                        break;
                    case "SAVE":
                        Save();
                        break;
                    case "LOAD":
                        Load();
                        break;
                    case "CLEARLOG":
                        Logger.Clear();
                        break;
                    case "CLEARSTORAGE":
                        clearStorage = true;
                        break;
                    case "TEST":
                        Signal.Send(Signal.SignalType.DOCK);
                        break;
                    default:
                        Logger.Err("Unknown command ->" + arg0 + "<-");
                        break;
                }
            }
            catch (Exception exception)
            {
                Logger.Err("Command exception -< " + command + " >-< " + exception.Message + " >-");
            }
        }

        private static class MainHelper
        { // MainHelper
            public delegate void Updater(ref string msg);
            public static void TimedRunIf(ref UpdateType update, UpdateType what, Updater run, ref string argument)
            {
                if ((update & what) == 0)
                {
                    return;
                }
                run(ref argument);
                update &= ~what;
            }

            public static void TimedRunDefault(ref UpdateType update, Updater run, ref string argument)
            {
                TimedRunIf(ref update, update, run, ref argument);
            }

            public static void WriteStats(Program p)
            {
                try
                {
                    p.Echo("SAMv" + VERSION + "\n" + Pannels.U() + "\n" + p.shipCommand.Ƣ());
                }
                catch (Exception e)
                {
                    p.Echo(e.Message);
                }
            }
        }

        private void Main(string argument, UpdateType updateSource)
        { // Main
            var update = updateSource;
            try
            {
                MainHelper.TimedRunIf(ref updateSource, UpdateType.Once, this.Once, ref argument);
                MainHelper.TimedRunIf(ref updateSource, UpdateType.Update100, this.Update100, ref argument);
                MainHelper.TimedRunIf(ref updateSource, UpdateType.IGC, this.UpdateIGC, ref argument);
                MainHelper.TimedRunIf(ref updateSource, UpdateType.Update10, this.Update10, ref argument);
                MainHelper.TimedRunDefault(ref updateSource, this.HandleCommand, ref argument);
                shipCommand.Ɵ((float)Runtime.CurrentInstructionCount / (float)Runtime.MaxInstructionCount, update);
            }
            catch (Exception exception)
            {
                Logger.Err("Main exception: " + exception.Message);
                Echo("Main exception: " + exception.Message);
            }
        }

        private void Once(ref string unused)
        {
            try
            {
                this.ScanGrid();
            }
            catch (Exception exception) {
                Logger.Err("Once ScanGrid exception: " + exception.Message);
            }
        }
        private MyIGCMessage igcData;
        private void UpdateIGC(ref string msg)
        {
            if (msg == TAG)
            {
                while (listener.HasPendingMessage)
                {
                    igcData = listener.AcceptMessage();
                    try
                    {
                        DockSystem.Listen((string)igcData.Data);
                    }
                    catch (Exception exception)
                    {
                        Logger.Err("Antenna Docks.Listen exception: " + exception.Message);
                    }
                }
            }
            else if (msg == LEADER_TAG)
            {
                while (leaderListener.HasPendingMessage)
                {
                    igcData = leaderListener.AcceptMessage();
                    try
                    {
                        Leader.ProcessLeaderMsg((string)igcData.Data);
                    }
                    catch (Exception exception)
                    {
                        Logger.Err("Antenna Follower.ProcessLeaderMsg exception: " + exception.Message);
                    }
                }
            }
            else if (msg == CMD_TAG)
            {
                while (cmdListener.HasPendingMessage)
                {
                    igcData = cmdListener.AcceptMessage();
                    try
                    {
                        Commander.ProcessCmd(this, (string)igcData.Data);
                    }
                    catch (Exception exception)
                    {
                        Logger.Err("Antenna Commander.ProcessCmd exception: " + exception.Message);
                    }
                }
            }
            else if (msg == CMD_RES_TAG)
            {
                while (cmdResListener.HasPendingMessage)
                {
                    igcData = cmdResListener.AcceptMessage();
                    try
                    {
                        Terminal.ProcessResponse((string)igcData.Data);
                    }
                    catch (Exception exception) { Logger.Err("Antenna Terminal.ProcessResponse exception: " + exception.Message); }
                }
            }
        }

        private void Update10(ref string unused)
        {
            try
            {
                Pannels.Print();
            }
            catch (Exception exception) { Logger.Err("Update10 Pannels.Print exception: " + exception.Message); }
            try
            {
                Animation.Run();
            }
            catch (Exception exception)
            {
                Logger.Err("Update10 Animation.Run exception: " + exception.Message);
            }
            try
            {
                Pilot.Tick();
            }
            catch (Exception exception)
            {
                Logger.Err("Update10 Pilot.Tick exception: " + exception.Message);
            }
            if (Me.CustomName.Contains("DEBUG"))
            {
                this.DebugPrintLogging();
            }
            MainHelper.WriteStats(this);
        }

        private void Update100(ref string ε)
        {
            try
            {
                this.ScanGrid();
            }
            catch (Exception exception)
            {
                Logger.Err("Update100 ScanGrid exception: " + exception.Message);
            }
            try
            {
                DockSystem.Advertise(this);
            }
            catch (Exception exception)
            {
                Logger.Err("Update100 Docks.Advertise exception: " + exception.Message);
            }
            try
            {
                Leader.Advertise(this);
            }
            catch (Exception exception)
            {
                Logger.Err("Update100 Leader.Advertise exception: " + exception.Message);
            }
            try
            {
                ConnectorControl.CheckConnect();
            }
            catch (Exception exception)
            {
                Logger.Err("Update100 ConnectorControl.CheckConnect exception: " + exception.Message);
            }
            try
            {
                this.SendSignals();
            }
            catch (Exception exception)
            {
                Logger.Err("Update100 SendSignals exception: " + exception.Message);
            }
            try
            {
                Commander.Tick();
            }
            catch (Exception exception)
            {
                Logger.Err("Update100 Commander.Tick exception: " + exception.Message);
            }
            try
            {
                Terminal.TickReader(this);
            }
            catch (Exception exception)
            {
                Logger.Err("Update100 Terminal.TickReader exception: " + exception.Message);
            }
        }

        private static class DockData
        {  // DockData
            public static int currentDockCount = 0;
            public static int selectedDockNAV = 0, selectedTopNAV = 0;
            public static int selectedDockCONF = 0, selectedTopCONF = 0;
            public static List<Dock> selectedDocks = new List<Dock>();
            public static List<Dock> docks = new List<Dock>();
            public static Dictionary<long, Dock> dynamic = new Dictionary<long, Dock>();
            public static Dock GetDock(long entityId)
            {
                for (int i = 0; i < docks.Count; i++)
                {
                    if (docks[i].blockEntityId == entityId)
                    {
                        return docks[i];
                    }
                }
                return null;
            }

            public static Dock GetDock(string dockName)
            {
                for (int i = 0; i < docks.Count; i++)
                {
                    if (docks[i].blockName == dockName)
                    {
                        return docks[i];
                    }
                }
                throw new Exception("Connector ->" + dockName + "<- was not found.");
            }

            public static Dock GetSelected()
            {
                if (selectedDocks.Count == 0)
                {
                    return null;
                }
                return selectedDocks[selectedDockNAV];
            }

            private static void SelectNAV()
            {
                if (selectedDockNAV < 0 || selectedDockNAV >= selectedDocks.Count)
                {
                    return;
                }
                selectedDocks[selectedDockNAV].NextJob();
            }

            private static void SelectCONF()
            {
                if (selectedDockCONF < 0 || selectedDockCONF >= docks.Count)
                {
                    return;
                }
                dock = docks[selectedDockCONF];
                if (selectedDocks.Contains(dock))
                {
                    selectedDocks.Remove(dock);
                }
                else
                {
                    selectedDocks.Add(dock);
                }
                BalanceDisplays();
            }

            private static void AddOrbit()
            {
                if (RemoteControl.block == null)
                {
                    Logger.Err("No Remote Control");
                    return;
                }
                Vector3D gravity = RemoteControl.block.GetNaturalGravity();
                if (gravity == Vector3D.Zero)
                {
                    Logger.Err("No Gravity detected");
                    return;
                }
                Vector3D pos = RemoteControl.block.CenterOfMass;
                Vector3D forward = RemoteControl.block.WorldMatrix.Forward;
                Vector3D up = RemoteControl.block.WorldMatrix.Up;
                Vector3D newPos = (-45000.0 * Vector3D.Normalize(gravity)) + pos + (1000.0 * forward);
                string dockName = "Orbit";
                Dock d = Dock.NewDock(newPos, forward, up, dockName);
                Logger.Pos("Orbit", ref newPos);
                docks.Add(d);
                docks.Sort();
                BalanceDisplays();
            }

            private static void AddDock(bool stance, string param)
            {
                if (RemoteControl.block == null)
                {
                    Logger.Err("No Remote Control");
                    return;
                }
                Vector3D pos = RemoteControl.block.CenterOfMass;
                Vector3D forward = stance ? RemoteControl.block.WorldMatrix.Forward : Vector3D.Zero;
                Vector3D up = stance ? RemoteControl.block.WorldMatrix.Up : Vector3D.Zero;
                string dockName = Helper.FormatedWaypoint(stance, currentDockCount);
                currentDockCount++;
                bool addGPS = false;
                IMyShipConnector connector = ConnectorControl.OtherConnected();
                if (connector != null)
                {
                    up = connector.WorldMatrix.Up;
                    pos = connector.GetPosition();
                    forward = Vector3D.Normalize(connector.OtherConnector.GetPosition() - connector.GetPosition());
                    dockName = connector.CustomName.Trim();
                }
                if (param != "")
                {
                    string tempDockName;
                    GPS gps = new GPS(param);
                    if (gps.valid)
                    {
                        connector = null;
                        pos = gps.pos;
                        tempDockName = gps.name;
                        addGPS = true;
                    }
                    else
                    {
                        tempDockName = param;
                    }
                    tempDockName = tempDockName.Trim();
                    if (tempDockName == "")
                    {
                        Logger.Err("Invalid Dock name");
                    }
                    else
                    {
                        dockName = tempDockName;
                    }
                }
                Dock d = Dock.NewDock(pos, forward, up, dockName);
                if (addGPS)
                {
                    Logger.Info("Added new GPS location: " + dockName);
                }
                else if (param != "")
                {
                    Logger.Info("Added current GPS location: " + dockName);
                }
                else
                {
                    Logger.Info("New connected Dock: " + dockName);
                }
                if (connector != null)
                {
                    d.blockEntityId = connector.EntityId;
                    d.cubeSize = connector.CubeGrid.GridSizeEnum;
                    d.gridEntityId = connector.CubeGrid.EntityId;
                    d.gridName = connector.CubeGrid.CustomName;
                    d.Touch();
                }
                docks.Add(d);
                docks.Sort();
                BalanceDisplays();
            }

            public static Dock AddDock(string dockName, Vector3D pos)
            {
                Dock d = Dock.NewDock(pos, Vector3D.Zero, Vector3D.Zero, dockName);
                docks.Add(d);
                docks.Sort();
                BalanceDisplays();
                return d;
            }

            private static void RemDock()
            {
                if (selectedDockCONF < 0 || selectedDockCONF >= docks.Count)
                {
                    return;
                }
                dock = docks[selectedDockCONF];
                if (dock.gridEntityId != 0 && dock.Fresh())
                {
                    return;
                }
                selectedDocks.Remove(dock);
                docks.Remove(dock);
                dynamic.Remove(dock.blockEntityId);
                BalanceDisplays();
            }

            public static void BalanceDisplays()
            {
                if (selectedDockNAV < 0)
                {
                    selectedDockNAV = selectedDocks.Count - 1;
                }
                if (selectedDockNAV >= selectedDocks.Count)
                {
                    selectedDockNAV = 0;
                }
                if (selectedDockNAV < selectedTopNAV)
                {
                    selectedTopNAV = selectedDockNAV;
                }
                if (selectedDockNAV >= selectedTopNAV + MAX_ENTRIES_NAV)
                {
                    selectedTopNAV = selectedDockNAV - MAX_ENTRIES_NAV + 1;
                }
                if (selectedDockCONF < 0)
                {
                    selectedDockCONF = docks.Count - 1;
                }
                if (selectedDockCONF >= docks.Count)
                {
                    selectedDockCONF = 0;
                }
                if (selectedDockCONF < selectedTopCONF)
                {
                    selectedTopCONF = selectedDockCONF;
                }
                if (selectedDockCONF >= selectedTopCONF + ʤ)
                {
                    selectedTopCONF = selectedDockCONF - ʤ + 1;
                }
            }

            public static void NAVScreenHandle(Pannels.ScreenAction sa)
            {
                NAVScreenHandle(sa, "");
            }

            public static void NAVScreenHandle(Pannels.ScreenAction sa, string param)
            {
                switch (sa)
                {
                    case Pannels.ScreenAction.Prev:
                        --selectedDockNAV;
                        break;
                    case Pannels.ScreenAction.Next:
                        ++selectedDockNAV;
                        break;
                    case Pannels.ScreenAction.Select:
                        SelectNAV();
                        break;
                    case Pannels.ScreenAction.Add:
                        AddDock(false, param);
                        break;
                    case Pannels.ScreenAction.AddStance:
                        AddDock(true, param);
                        break;
                    case Pannels.ScreenAction.Rem:
                        break;
                }
                BalanceDisplays();
            }

            public static void CONFScreenHandle(Pannels.ScreenAction sa)
            {
                CONFScreenHandle(sa, "");
            }

            public static void CONFScreenHandle(Pannels.ScreenAction sa, string param)
            {
                switch (sa)
                {
                    case Pannels.ScreenAction.Prev:
                        --selectedDockCONF;
                        break;
                    case Pannels.ScreenAction.Next:
                        ++selectedDockCONF;
                        break;
                    case Pannels.ScreenAction.Select:
                        SelectCONF();
                        break;
                    case Pannels.ScreenAction.Add:
                        AddDock(false, param);
                        break;
                    case Pannels.ScreenAction.AddOrbit:
                        AddOrbit();
                        break;
                    case Pannels.ScreenAction.AddStance:
                        AddDock(true, param);
                        break;
                    case Pannels.ScreenAction.Rem:
                        RemDock();
                        break;
                }
                BalanceDisplays();
            }

            private static Dock dock;
            private static string str, status, cmdStatus;
            private static int index;
            private static int MAX_ENTRIES_NAV = 11;
            public static string PrintBufferNAV()
            {
                str = Animation.Rotator() + " SAMv2 ";
                status = Navigation.Status();
                if (status != "")
                {
                    if (Commander.currentDock != null)
                    {
                        return str + status + "\n   to [" + Commander.currentDock.gridName + "] " + Commander.currentDock.blockName;
                    }
                    return str + status + "\n   to GPS marker";
                }
                if (Commander.active)
                {
                    return str + "waiting...";
                }
                if (!Pilot.running)
                {
                    return str + "disabled";
                }
                return str + "";
            }

            public static string PrintBufferCONF(bool active)
            {
                str = ñ.õ("Navigation", active);
                status = Navigation.Status();
                cmdStatus = Commander.active ? "waiting..." : "disabled";
                str += "   " + ((status == "" && !Pilot.running) ? cmdStatus : status) + "\n";
                if (selectedDocks.Count() == 0)
                {
                    return str + "\n - No docks selected.\n   Use Configuration\n   screen to select\n   them.";
                }
                str += (selectedTopNAV > 0) ? "     /\\/\\/\\\n" : "     ------\n";
                for (int i = 0; i < selectedDocks.Count; ++i)
                {
                    if (i < selectedTopNAV || i >= selectedTopNAV + MAX_ENTRIES_NAV)
                    {
                        continue;
                    }
                    dock = selectedDocks[i];
                    str += ((selectedDockNAV == i) ? " >" : "  ") + (dock.Fresh() ? "" : "? ");
                    if (dock.job != Dock.JobType.NONE)
                    {
                        str += "{" + dock.JobName() + "}";
                    }
                    str += "[" + dock.gridName + "] " + dock.blockName + "\n";
                }
                str += (selectedTopNAV + MAX_ENTRIES_NAV < selectedDocks.Count) ? "     \\/\\/\\/\n" : "     ------\n";
                return str;
            }

            private static int ʤ = 12;
            public static string ʥ(bool Ö)
            {
                str = ñ.õ("Configuration", Ö);
                if (docks.Count() == 0)
                {
                    return str + "\n - No available docks\n   to configure.";
                }
                str += (selectedTopCONF > 0) ? "     /\\/\\/\\\n" : "     ------\n";
                for (int Ƹ = 0; Ƹ < docks.Count; Ƹ++)
                {
                    if (Ƹ < selectedTopCONF || Ƹ >= selectedTopCONF + ʤ)
                    {
                        continue;
                    }
                    dock = docks[Ƹ];
                    index = selectedDocks.IndexOf(dock) + 1;
                    str += (index != 0) ? index.ToString().PadLeft(2, ' ') : "  ";
                    str += ((selectedDockCONF == Ƹ) ? " >" : "  ");
                    str += (dock.Fresh() ? " " : " ? ") + "[" + dock.gridName + "] " + dock.blockName + "\n";
                }
                str += (selectedTopCONF + ʤ < docks.Count) ? "     \\/\\/\\/\n" : "     ------\n";
                return str;
            }
        }

        private static class DockSystem
        { // DockSystem
            private static string ʗ;
            private static string ʉ;
            private static List<VectorPath> Ʀ = new List<VectorPath>();
            private static string ʊ()
            {
                Serializer.InitPack();
                Serializer.Pack(ADVERT_ID);
                if (!Block.GetProperty(GridBlocks.masterProgrammableBlock.EntityId, "Name", ref ʗ))
                {
                    ʗ = GridBlocks.masterProgrammableBlock.CubeGrid.CustomName;
                }
                Serializer.Pack(GridBlocks.masterProgrammableBlock.CubeGrid.EntityId);
                Serializer.Pack(ʗ);
                Serializer.Pack(GridBlocks.masterProgrammableBlock.CubeGrid.GridSizeEnum);
                Serializer.Pack(GridBlocks.shipConnectorBlocks.Count());
                foreach (IMyShipConnector Ľ in GridBlocks.shipConnectorBlocks)
                {
                    if (Block.HasProperty(Ľ.EntityId, "MAIN"))
                    {
                        continue;
                    }
                    Serializer.Pack(Ľ.EntityId);
                    if (!Block.GetProperty(Ľ.EntityId, "Name", ref ʗ))
                    {
                        ʗ = Ľ.CustomName.Trim();
                    }
                    Serializer.Pack(ʗ);
                    Serializer.Pack(Ľ.GetPosition());
                    if (Block.HasProperty(Ľ.EntityId, "REV"))
                    {
                        Serializer.Pack(Ľ.WorldMatrix.Backward);
                    }
                    else
                    {
                        Serializer.Pack(Ľ.WorldMatrix.Forward);
                    }
                    Serializer.Pack(Ľ.WorldMatrix.Up);
                    Ʀ.Clear();
                    foreach (IMyTextPanel R in GridBlocks.textPanelBlocks)
                    {
                        if (!Block.GetProperty(R.EntityId, "Name", ref ʉ))
                        {
                            continue;
                        }
                        if (ʉ != ʗ)
                        {
                            continue;
                        }
                        Ʀ.Add(new VectorPath(R.GetPosition(), -R.WorldMatrix.Forward));
                    }
                    Serializer.Pack(Ʀ);
                }
                return Serializer.serialized;
            }

            public static void Advertise(Program p)
            {
                if (!Block.HasProperty(GridBlocks.masterProgrammableBlock.EntityId, "ADVERTISE"))
                {
                    return;
                }
                if (GridBlocks.shipConnectorBlocks.Count() == 0 || GridBlocks.shipConnectorBlocks.Count() == GridBlocks.mainShipConnectorBlocks.Count())
                {
                    return;
                }
                ʊ();
                p.IGC.SendBroadcastMessage<string>(TAG, Serializer.serialized);
            }

            private static long ƨ;
            private static long ƪ;
            private static string Ʃ;
            private static VRage.Game.MyCubeSize ʋ;
            private static int ǡ;
            private static Dock Ȯ;
            private static bool ʌ;
            private static string ʍ;
            private static bool ʎ;

            public static void Listen(string ʐ)
            {
                Serializer.InitUnpack(ʐ);
                ʍ = Serializer.UnpackString();
                if (ʍ == ADVERT_ID_VER)
                {
                    ʎ = true;
                }
                if (!ʎ && ʍ != ADVERT_ID)
                {
                    return;
                }
                if (ʎ)
                {
                    Serializer.UnpackLong();
                }
                ƨ = Serializer.UnpackLong();
                Ʃ = Serializer.UnpackString();
                if (!ʎ)
                {
                    ʋ = Serializer.UnpackCubeSize();
                }
                ǡ = Serializer.UnpackInt();
                for (int Ƹ = 0; Ƹ < ǡ; ++Ƹ)
                {
                    ƪ = Serializer.UnpackLong();
                    if (DockData.dynamic.ContainsKey(ƪ))
                    {
                        Ȯ = DockData.dynamic[ƪ];
                        ʌ = true;
                    }
                    else
                    {
                        Ȯ = new Dock();
                        ʌ = false;
                    }
                    Ȯ.Touch();
                    Ȯ.blockName = Serializer.UnpackString();
                    Ȯ.stance = new Stance(Serializer.UnpackVector3D(), Serializer.UnpackVector3D(), Serializer.UnpackVector3D());
                    Ȯ.lastSeen = DateTime.Now.Ticks;
                    Ȯ.blockEntityId = ƪ;
                    Ȯ.gridEntityId = ƨ;
                    Ȯ.gridName = Ʃ;
                    if (ʎ)
                    {
                        Ȯ.cubeSize = Serializer.UnpackCubeSize();
                    }
                    else
                    {
                        Ȯ.cubeSize = ʋ;
                    }
                    Ȯ.approachPath = Serializer.UnpackListVectorPath();
                    Ȯ.SortApproachVectorsByDistance(Ȯ.stance.position);
                    if (!ʌ)
                    {
                        DockData.dynamic[ƪ] = Ȯ;
                        DockData.docks.Add(Ȯ);
                        DockData.docks.Sort();
                    }
                }
            }
        }

        private static class CustomData
        { // CustomData
            public static System.Text.RegularExpressions.Regex customDataRegex = new System.Text.RegularExpressions.Regex(
                "\\s*" + TAG + "\\.([a-zA-Z0-9]*)([:=]{1}([\\S]*))?", System.Text.RegularExpressions.RegexOptions.IgnoreCase);
            private static System.Text.RegularExpressions.Match match;
            private static char[] lineSeparator = new char[] { '\n' };
            private static char[] attributeSeparator = new char[]{':', '='};
            private static string[] lines;
            private static string tagUpper;
            private static string attributeCap;
            private static string value;
            private static string build;
            private static bool exclusiveFound;
            private static long entityId;
            private static bool matched;
            private static string trim;
            public static bool Sanitize(ref IMyTerminalBlock block, ref BlockProfile Helper)
            {
                lines = block.CustomData.Split(lineSeparator);
                build = "";
                exclusiveFound = false;
                matched = false;
                entityId = block.EntityId;
                foreach (string line in lines)
                {
                    trim = line.Trim();
                    if (trim == "")
                    {
                        continue;
                    }
                    match = customDataRegex.Match(trim);
                    matched = match.Success || matched;
                    if (match.Groups.Count == 4)
                    {
                        if (match.Groups[1].Value != "")
                        {
                            if (match.Groups[3].Value != "")
                            {
                                attributeCap = Helper.Capitalize(match.Groups[1].Value);
                                if (attributeCap != "")
                                {
                                    value = match.Groups[3].Value;
                                    build += TAG + "." + attributeCap + "=" + value + "\n";
                                    Block.UpdateProperty(entityId, attributeCap, value);
                                    continue;
                                }
                            }
                            else
                            {
                                tagUpper = match.Groups[1].Value.ToUpper();
                                if (Helper.exclusiveTags.Contains(tagUpper))
                                {
                                    if (exclusiveFound)
                                    {
                                        build += trim + "\n";
                                        continue;
                                    }
                                    exclusiveFound = true;
                                }
                                else if (!Helper.tags.Contains(tagUpper))
                                {
                                    build += trim + "\n";
                                    continue;
                                }
                                Block.UpdateProperty(entityId, tagUpper, "");
                                build += TAG + "." + tagUpper + "\n";
                                continue;
                            }
                        }
                        build += TAG + ".\n";
                        continue;
                    }
                    else
                    {
                        build += trim + "\n";
                    }
                }
                if (matched)
                {
                    block.CustomData = build;
                }
                return matched;
            }
        }

        private static class CustomName
        {  // CustomName
            private static char[] attributeSeparator = new char[] { ':', '=' };
            private static System.Text.RegularExpressions.Regex tagSimpleRegex = new System.Text.RegularExpressions.Regex("\\[(" + TAG + "[\\s\\S]*)\\]",
                System.Text.RegularExpressions.RegexOptions.IgnoreCase);
            private static string tagRegStr = TAG + "\\s*(\\S*)\\s*(\\S*)\\s*(\\S*)\\s*(\\S*)\\s*(\\S*)\\s*(\\S*)\\s*(\\S*)\\s*(\\S*)\\s*(\\S*)\\s*"
                + "(\\S*)\\s*(\\S*)\\s*(\\S*)\\s*(\\S*)\\s*(\\S*)\\s*(\\S*)\\s*(\\S*)\\s*(\\S*)\\s*";
            private static System.Text.RegularExpressions.Regex tagRegex = new System.Text.RegularExpressions.Regex(tagRegStr, System.Text.RegularExpressions.RegexOptions.IgnoreCase);
            private static System.Text.RegularExpressions.Match simpleMatch;
            private static System.Text.RegularExpressions.Match match;
            private static string build;
            private static string subTag;
            private static string subTagUpper;
            private static bool foundExclusive;
            private static string[] attributePair;
            private static string attributeCap;
            private static long entityId;
            public static bool Sanitize(ref IMyTerminalBlock block, ref BlockProfile profile)
            {
                simpleMatch = tagSimpleRegex.Match(block.CustomName);
                if (!simpleMatch.Success)
                {
                    return false;
                }
                match = tagRegex.Match(simpleMatch.Groups[1].Value);
                if (!match.Success)
                {
                    return false;
                }
                entityId = block.EntityId;
                foundExclusive = false;
                build = "[" + TAG;
                for (int i = 1; i < match.Groups.Count; ++i)
                {
                    subTag = match.Groups[i].Value;
                    if (subTag == "")
                    {
                        break;
                    }
                    subTagUpper = subTag.ToUpper();
                    if (profile.exclusiveTags.Contains(subTagUpper))
                    {
                        if (foundExclusive)
                        {
                            continue;
                        }
                        foundExclusive = true;
                        build += " " + subTagUpper;
                        Block.UpdateProperty(entityId, subTagUpper, "");
                        continue;
                    }
                    if (profile.tags.Contains(subTagUpper))
                    {
                        build += " " + subTagUpper;
                        Block.UpdateProperty(entityId, subTagUpper, "");
                        continue;
                    }
                    attributePair = subTag.Split(attributeSeparator);
                    if (attributePair.Count() > 1)
                    {
                        attributeCap = profile.Capitalize(attributePair[0]);
                        if (attributeCap != "")
                        {
                            Block.UpdateProperty(entityId, attributeCap, attributePair[1]);
                            build += " " + attributeCap + "=" + attributePair[1];
                            continue;
                        }
                        build += " " + attributeCap.ToLower() + "=" + attributePair[1];
                        continue;
                    }
                    build += " " + subTag.ToLower();
                }
                build += "]";
                block.CustomName = block.CustomName.Replace(simpleMatch.Groups[0].Value, build);
                return true;
            }
        }

        private static class Profile
        { // Profiles
            private static string[] empty = new string[]{};
            private static string[] ignore = new string[]{ "IGNORE" };
            private static string[] name = new string[]{ "Name" };
            private static string[] meTags = new string[]{ "DEBUG", "ADVERTISE", "NODAMPENERS", "IGNOREGRAVITY", "LEADER" };
            private static string[] exclusiveTags = new string[]{"LIST", "LOOP"};
            private static string[] pbAttributes = new string[]{"Follow","FollowFront","FollowUp","FollowRight","Name","Speed","Wait", "TaxiingDistance",
                "ApproachDistance","DockDistance","UndockDistance","DockingSpeed","TaxiingSpeed","MaxSpeed","Aggro","ConvergingSpeed",
                "MassExcess","TaxiingPanelDistance","ApproachingSpeed","EffectiveThrust"};
            private static string[] textPanelTags = new string[]{ "OVR" };
            private static string[] textPanelExclusiveTags = new string[]{ "LOG", "NAV", "CONF", "DATA", "STAT" };
            private static string[] cockpitPanelTags = new string[]{ "OVR" };
            public static string[] panelTags = new string[]{ "Panel0", "Panel1", "Panel2", "Panel3", "Panel4", "Panel5", "Panel6", "Panel7", "Panel8", "Panel9" };
            private static string[] connectorTags = new string[]{ "REV", "MAIN" };
            private static string[] timerTags = new string[]{ "DOCKED", "NAVIGATED", "UNDOCKED", "STARTED" };
            public static string[] capacity = new string[]{ "Full", "Empty" };
            private static string[] batteryTags = new string[]{ "FORCE" };
            private static string[] gastankTags = new string[]{"FORCE","CARGO"};
            public static BlockProfile blockProfile = new BlockProfile(ref meTags, ref exclusiveTags, ref pbAttributes);
            public static Dictionary<Type, BlockProfile> blockProfileDict = new Dictionary<Type, BlockProfile>{{typeof(IMyProgrammableBlock),blockProfile},
                {typeof(IMyRemoteControl),new BlockProfile(ref empty,ref empty,ref empty)},
                {typeof(IMyCameraBlock),new BlockProfile(ref empty,ref empty,ref empty)},
                {typeof(IMyRadioAntenna),new BlockProfile(ref empty,ref empty,ref empty)},
                {typeof(IMyLaserAntenna),new BlockProfile(ref empty,ref empty,ref empty)},
                {typeof(IMyShipConnector),new BlockProfile(ref connectorTags,ref empty,ref name)},
                {typeof(IMyTextPanel),new BlockProfile(ref textPanelTags,ref textPanelExclusiveTags,ref name)},
                {typeof(IMyCockpit),new BlockProfile(ref cockpitPanelTags,ref empty,ref panelTags)},
                {typeof(IMyTimerBlock),new BlockProfile(ref timerTags,ref empty,ref empty)},
                {typeof(IMyBatteryBlock),new BlockProfile(ref batteryTags,ref empty,ref capacity)},
                {typeof(IMyGasTank),new BlockProfile(ref gastankTags,ref empty,ref capacity)},
                {typeof(IMyCargoContainer),new BlockProfile(ref empty,ref empty,ref capacity)},
                {typeof(IMyThrust),new BlockProfile(ref ignore,ref empty,ref empty)},};
        }

        private static class Block
        { // Block
            public static bool ValidType(ref IMyTerminalBlock block, Type type)
            {
                return ValidProfile(ref block, Profile.blockProfileDict[type]);
            }

            public static bool ValidProfile(ref IMyTerminalBlock block, BlockProfile profile)
            {
                bool customNameSanitized = CustomName.Sanitize(ref block, ref profile);
                bool customDataSanitized = CustomData.Sanitize(ref block, ref profile);
                return customNameSanitized || customDataSanitized;
            }

            private static Dictionary<long, Dictionary<string, string>> properties = new Dictionary<long, Dictionary<string, string>>();
            public static void UpdateProperty(long entityId, string property, string value)
            {
                if (value == null)
                {
                    value = "";
                }
                if (properties.ContainsKey(entityId))
                {
                    properties[entityId][property] = value;
                }
                else
                {
                    properties[entityId] = new Dictionary<string, string> { { property, value } };
                }
            }

            public static void ClearProperties()
            {
                foreach (KeyValuePair<long, Dictionary<string, string>> entities in properties)
                {
                    entities.Value.Clear();
                }
            }

            public static bool HasProperty(long entityId, string name)
            {
                if (!properties.ContainsKey(entityId))
                {
                    return false;
                }
                if (!properties[entityId].ContainsKey(name))
                {
                    return false;
                }
                return true;
            }

            public static bool GetProperty(long entityId, string name, ref string value)
            {
                if (!HasProperty(entityId, name))
                {
                    return false;
                }
                value = properties[entityId][name];
                return true;
            }

            public static void RemoveProperty(long entityId, string name)
            {
                if (!properties.ContainsKey(entityId))
                {
                    return;
                }
                properties[entityId].Remove(name);
            }
        }

        private static class GridBlocks
        { // GridBlocks
            public static IMyProgrammableBlock masterProgrammableBlock;
            public static Dictionary<string, PairCounter> blockCount = new Dictionary<string, PairCounter>();
            public static List<IMyTerminalBlock> terminalBlocks = new List<IMyTerminalBlock>();
            public static List<IMyRemoteControl> remoteControlBlocks = new List<IMyRemoteControl>();
            public static List<IMyCameraBlock> cameraBlocks = new List<IMyCameraBlock>();
            public static List<IMyRadioAntenna> radioAntennaBlocks = new List<IMyRadioAntenna>();
            public static List<IMyLaserAntenna> laserAntennaBlocks = new List<IMyLaserAntenna>();
            public static List<IMyProgrammableBlock> programmableBlocks = new List<IMyProgrammableBlock>();
            public static List<IMyShipConnector> shipConnectorBlocks = new List<IMyShipConnector>();
            public static List<IMyShipConnector> mainShipConnectorBlocks = new List<IMyShipConnector>();
            public static List<IMyTextPanel> textPanelBlocks = new List<IMyTextPanel>();
            public static List<IMyGyro> gyroBlocks = new List<IMyGyro>();
            public static List<IMyThrust> thrusterBlocks = new List<IMyThrust>();
            public static List<IMyTimerBlock> timerBlocks = new List<IMyTimerBlock>();
            public static List<IMyCockpit> cockpitBlocks = new List<IMyCockpit>();
            public static List<IMyBatteryBlock> batteryBlocks = new List<IMyBatteryBlock>();
            public static List<IMyCargoContainer> cargoBlocks = new List<IMyCargoContainer>();
            public static List<IMyGasTank> tankBlocks = new List<IMyGasTank>();
            public static List<IMyBatteryBlock> swapChargeBatteryBlocks = new List<IMyBatteryBlock>();
            public static List<IMyGasTank> chargeTankBlocks = new List<IMyGasTank>();
            public static IMyTerminalBlock terminalBlock;
            public static IMyRemoteControl remoteControl;
            public static IMyCameraBlock cameraBlock;
            public static IMyRadioAntenna radioAntenna;
            public static IMyLaserAntenna laserAntenna;
            public static IMyProgrammableBlock programmableBlock;
            public static IMyShipConnector shipConnector;
            public static IMyTextPanel textPanel;
            public static IMyGyro gyroBlock;
            public static IMyThrust thrustBlock;
            public static IMyTimerBlock timerBlock;
            public static IMyCockpit cockpitBlock;
            public static IMyBatteryBlock batteryBlock;
            public static IMyCargoContainer cargoBlock;
            public static IMyGasTank tankBlock;

            public static void Clear()
            {
                foreach (string key in blockCount.Keys)
                {
                    blockCount[key].Recount();
                }
                terminalBlocks.Clear();
                remoteControlBlocks.Clear();
                cameraBlocks.Clear();
                radioAntennaBlocks.Clear();
                laserAntennaBlocks.Clear();
                programmableBlocks.Clear();
                shipConnectorBlocks.Clear();
                mainShipConnectorBlocks.Clear();
                textPanelBlocks.Clear();
                gyroBlocks.Clear();
                thrusterBlocks.Clear();
                timerBlocks.Clear();
                cockpitBlocks.Clear();
                batteryBlocks.Clear();
                cargoBlocks.Clear();
                tankBlocks.Clear();
            }

            public static void UpdateCount(string key)
            {
                if (blockCount.ContainsKey(key))
                {
                    blockCount[key].newC++;
                }
                else
                {
                    blockCount[key] = new PairCounter();
                }
            }

            private static int count;
            public static void LogDifference()
            {
                foreach (string key in blockCount.Keys)
                {
                    count = blockCount[key].Diff();
                    if (count > 0)
                    {
                        Logger.Info(String.Format("Found {0}x {1}", count, key));
                    }
                    else if (count < 0)
                    {
                        Logger.Info(String.Format("Lost {0}x {1}", -count, key));
                    }
                }
            }

            public static bool AddBlock(IMyTerminalBlock block)
            {
                if ((remoteControl = block as IMyRemoteControl) != null)
                {
                    if (!Block.ValidType(ref block, typeof(IMyRemoteControl)))
                    {
                        return false;
                    }
                    remoteControlBlocks.Add(remoteControl);
                }
                else if ((cameraBlock = block as IMyCameraBlock) != null)
                {
                    if (!Block.ValidType(ref block, typeof(IMyCameraBlock)
))
                    {
                        return false;
                    }
                    cameraBlocks.Add(cameraBlock);
                }
                else if ((radioAntenna = block as IMyRadioAntenna) != null)
                {
                    radioAntennaBlocks.Add(radioAntenna);
                }
                else if ((laserAntenna = block as IMyLaserAntenna) != null)
                {
                    laserAntennaBlocks.Add(laserAntenna);
                }
                else if ((programmableBlock = block as IMyProgrammableBlock) != null)
                {
                    if (!Block.ValidType(ref block, typeof(IMyProgrammableBlock)))
                    {
                        return false;
                    }
                    programmableBlocks.Add(programmableBlock);
                }
                else if ((shipConnector = block as IMyShipConnector) != null)
                {
                    if (!Block.ValidType(ref block, typeof(IMyShipConnector)))
                    {
                        return false;
                    }
                    shipConnectorBlocks.Add(shipConnector);
                    if (Block.HasProperty(shipConnector.EntityId, "MAIN"))
                    {
                        mainShipConnectorBlocks.Add(shipConnector);
                        GridBlocks.UpdateCount("MAIN " + block.DefinitionDisplayNameText);
                    }
                }
                else if ((textPanel = block as IMyTextPanel) != null)
                {
                    if (!Block.ValidType(ref block, typeof(IMyTextPanel)))
                    {
                        return false;
                    }
                    textPanelBlocks.Add(textPanel);
                }
                else if ((gyroBlock = block as IMyGyro) != null)
                {
                    gyroBlocks.Add(gyroBlock);
                }
                else if ((thrustBlock = block as IMyThrust) != null)
                {
                    if (Block.ValidType(ref block, typeof(IMyThrust)))
                    {
                        if (Block.HasProperty(block.EntityId, "IGNORE"))
                        {
                            return false;
                        }
                    }
                    thrusterBlocks.Add(thrustBlock);
                }
                else if ((timerBlock = block as IMyTimerBlock) != null)
                {
                    if (!Block.ValidType(ref block, typeof(IMyTimerBlock)))
                    {
                        return false;
                    }
                    timerBlocks.Add(timerBlock);
                }
                else if ((cockpitBlock = block as IMyCockpit) != null)
                {
                    if (!Block.ValidType(ref block, typeof(IMyCockpit)))
                    {
                        return false;
                    }
                    cockpitBlocks.Add(cockpitBlock);
                }
                else if ((batteryBlock = block as IMyBatteryBlock) != null)
                {
                    if (!Block.ValidType(ref block, typeof(IMyBatteryBlock)))
                    {
                        return false;
                    }
                    batteryBlocks.Add(batteryBlock);
                }
                else if ((cargoBlock = block as IMyCargoContainer) != null)
                {
                    if (!Block.ValidType(ref block, typeof(IMyCargoContainer)))
                    {
                        return false;
                    }
                    cargoBlocks.Add(cargoBlock);
                }
                else if ((tankBlock = block as IMyGasTank) != null)
                {
                    if (!Block.ValidType(ref block, typeof(IMyGasTank)))
                    {
                        return false;
                    }
                    tankBlocks.Add(tankBlock);
                }
                else
                {
                    return false;
                }
                return true;
            }

            private static string speed;
            private static float speedInt;
            private static double wait;
            private static bool gravity;
            public static void AddMe(IMyProgrammableBlock me)
            {
                masterProgrammableBlock = me;
                terminalBlock = me as IMyTerminalBlock;
                if (!Block.ValidProfile(ref terminalBlock, Profile.blockProfile))
                {
                    me.CustomName += " [" + TAG + "]";
                    return;
                }
                if (Block.GetProperty(terminalBlock.EntityId, "Speed", ref speed))
                {
                    if (float.TryParse(speed, out speedInt))
                    {
                        if (MAX_SPEED != speedInt)
                        {
                            MAX_SPEED = speedInt;
                            Logger.Info("Maximum speed changed to " + MAX_SPEED);
                        }
                    }
                }
                if (Block.GetProperty(terminalBlock.EntityId, "MaxSpeed", ref speed))
                {
                    if (float.TryParse(speed, out speedInt))
                    {
                        if (MAX_SPEED != speedInt)
                        {
                            MAX_SPEED = speedInt;
                            Logger.Info("Maximum speed changed to " + MAX_SPEED);
                        }
                    }
                }
                if (Block.GetProperty(terminalBlock.EntityId, "DockingSpeed", ref speed))
                {
                    if (float.TryParse(speed, out speedInt))
                    {
                        if (DOCKING_SPEED != speedInt)
                        {
                            DOCKING_SPEED = speedInt;
                            Logger.Info("Docking speed changed to " + DOCKING_SPEED);
                        }
                    }
                }
                if (Block.GetProperty(terminalBlock.EntityId, "TaxiingSpeed", ref speed))
                {
                    if (float.TryParse(speed, out speedInt))
                    {
                        if (TAXIING_SPEED != speedInt)
                        {
                            TAXIING_SPEED = speedInt;
                            Logger.Info("Taxiing speed changed to " + TAXIING_SPEED);
                        }
                    }
                }
                if (Block.GetProperty(terminalBlock.EntityId, "TaxiingDistance", ref speed))
                {
                    if (float.TryParse(speed, out speedInt))
                    {
                        if (TAXIING_DISTANCE != (float)speedInt)
                        {
                            TAXIING_DISTANCE = (float)speedInt;
                            Logger.Info("Taxiing distance changed to " + TAXIING_DISTANCE);
                        }
                    }
                }
                if (Block.GetProperty(terminalBlock.EntityId, "TaxiingPanelDistance", ref speed))
                {
                    if (float.TryParse(speed, out speedInt))
                    {
                        if (TAXIING_PANEL_DISTANCE != (float)speedInt)
                        {
                            TAXIING_PANEL_DISTANCE = (float)speedInt;
                            Logger.Info("Taxiing panel distance changed to " + TAXIING_PANEL_DISTANCE);
                        }
                    }
                }
                if (Block.GetProperty(terminalBlock.EntityId, "ApproachDistance", ref speed))
                {
                    if (float.TryParse(speed, out speedInt))
                    {
                        if (APPROACH_DISTANCE != (float)speedInt)
                        {
                            APPROACH_DISTANCE = (float)speedInt;
                            Logger.Info("Approach distance changed to " + APPROACH_DISTANCE);
                        }
                    }
                }
                if (Block.GetProperty(terminalBlock.EntityId, "ApproachingSpeed", ref speed))
                {
                    if (float.TryParse(speed, out speedInt))
                    {
                        if (APPROACHING_SPEED != speedInt)
                        {
                            APPROACHING_SPEED = speedInt;
                            Logger.Info("Approaching speed changed to " + APPROACHING_SPEED);
                        }
                    }
                }
                if (Block.GetProperty(terminalBlock.EntityId, "DockDistance", ref speed))
                {
                    if (float.TryParse(speed, out speedInt))
                    {
                        if (DOCK_DISTANCE != (float)speedInt)
                        {
                            DOCK_DISTANCE = (float)speedInt;
                            Logger.Info("Docking distance changed to " + DOCK_DISTANCE);
                        }
                    }
                }
                if (Block.GetProperty(terminalBlock.EntityId, "UndockDistance", ref speed))
                {
                    if (float.TryParse(speed, out speedInt))
                    {
                        if (UNDOCK_DISTANCE != (float)speedInt)
                        {
                            UNDOCK_DISTANCE = (float)speedInt;
                            Logger.Info("Undocking distance changed to " + UNDOCK_DISTANCE);
                        }
                    }
                }
                if (Block.GetProperty(terminalBlock.EntityId, "Wait", ref speed))
                {
                    if (Double.TryParse(speed, out wait))
                    {
                        Commander.waitTime = TimeSpan.FromSeconds(wait).Ticks;
                    }
                }
                gravity = Block.HasProperty(terminalBlock.EntityId, "IGNOREGRAVITY");
                if (gravity != Situation.ignoreGravity)
                {
                    Situation.ignoreGravity = gravity;
                    Logger.Info("Ship orientation " + (gravity ? "ignoring" : "using") + " gravity for alignment.");
                }
                if (Block.HasProperty(terminalBlock.EntityId, "LIST"))
                {
                    Commander.mode = Commander.Mode.LIST;
                }
                else if (Block.HasProperty(terminalBlock.EntityId, "LOOP"))
                {
                    Commander.mode = Commander.Mode.LOOP;
                }
                else
                {
                    Commander.mode = Commander.Mode.SINGLE;
                    Commander.active = false;
                }
            }

            private static int thrusterB, thrusterY;
            private static int CompareThrusters(IMyThrust thrusterX, IMyThrust thrusterY)
            {
                thrusterB = GridBlocks.thrusterY = 0;
                if (thrusterX.DefinitionDisplayNameText.Contains("Hydrogen "))
                {
                    thrusterB += 4;
                }
                else if (thrusterX.DefinitionDisplayNameText.Contains("Ion "))
                {
                    thrusterB += 2;
                }
                if (thrusterX.DefinitionDisplayNameText.Contains("Large "))
                {
                    thrusterB += 1;
                }
                if (thrusterY.DefinitionDisplayNameText.Contains("Hydrogen "))
                {
                    GridBlocks.thrusterY += 4;
                }
                else if (thrusterY.DefinitionDisplayNameText.Contains("Ion "))
                {
                    GridBlocks.thrusterY += 2;
                }
                if (thrusterY.DefinitionDisplayNameText.Contains("Large "))
                {
                    GridBlocks.thrusterY += 1;
                }
                return thrusterB - GridBlocks.thrusterY;
            }

            public static void EvaluateRemoteControls()
            {
                if (remoteControlBlocks.Count() == 1)
                {
                    RemoteControl.block = remoteControlBlocks[0];
                    ErrorState.Reset(ErrorState.Type.NoRemoteController);
                    ErrorState.Reset(ErrorState.Type.TooManyControllers);
                    return;
                };
                RemoteControl.block = null;
                if (!ErrorState.Get(ErrorState.Type.TooManyControllers) && remoteControlBlocks.Count() > 1)
                {
                    ErrorState.Set(ErrorState.Type.TooManyControllers);
                    Logger.Err("Too many remote controllers");
                }
            }

            public static void EvaluateCameraBlocks()
            {
                foreach (IMyCameraBlock camera in cameraBlocks)
                {
                    if (!camera.EnableRaycast)
                    {
                        camera.EnableRaycast = true;
                    }
                }
            }

            public static void EvaluateThrusters()
            {
                thrusterBlocks.Sort(CompareThrusters);
            }
        }

        private void ScanGrid()
        {
            Block.ClearProperties();
            GridBlocks.Clear();
            GridBlocks.AddMe(Me);
            this.GridTerminalSystem.GetBlocks(GridBlocks.terminalBlocks);
            foreach (IMyTerminalBlock block in GridBlocks.terminalBlocks)
            {
                if (!block.IsSameConstructAs(Me))
                {
                    continue;
                }
                if (block.EntityId == Me.EntityId)
                {
                    continue;
                }
                if (GridBlocks.AddBlock(block))
                {
                    GridBlocks.UpdateCount(block.DefinitionDisplayNameText);
                }
            }
            GridBlocks.EvaluateCameraBlocks();
            GridBlocks.EvaluateCameraBlocks();
            GridBlocks.EvaluateRemoteControls();
            GridBlocks.LogDifference();
            try
            {
                var chargeTargetGroupName = this.GridTerminalSystem.GetBlockGroupWithName(CHARGE_TARGET_GROUP_NAME);
                if (chargeTargetGroupName != null)
                {
                    chargeTargetGroupName.GetBlocksOfType<IMyBatteryBlock>(GridBlocks.swapChargeBatteryBlocks);
                    chargeTargetGroupName.GetBlocksOfType<IMyGasTank>(GridBlocks.chargeTankBlocks);
                }
            }
            catch (Exception exception)
            {
                Logger.Err("Update100 ScanGrid blockGroup exception: " + exception.Message);
            }
        }

        private static class Signal
        { // Signal
            public enum SignalType { DOCK, NAVIGATION, START, ř }; 
            public static Dictionary<SignalType, int> list = new Dictionary<SignalType, int>();
            private static HashSet<SignalType> lastSignal = new HashSet<SignalType> { };
            private static int SIGNAL_MAX_ATTEMPTS = 10;
            public static void Send(SignalType signal)
            {
                list[signal] = SIGNAL_MAX_ATTEMPTS;
            }

            public static void UpdateSignals()
            {
                foreach (KeyValuePair<SignalType, int> signalType in list)
                {
                    lastSignal.Add(signalType.Key);
                }
                foreach (SignalType signal in lastSignal)
                {
                    if (--list[signal] < 1)
                    {
                        list.Remove(signal);
                    }
                }
                lastSignal.Clear();
            }

            public static void Clear()
            {
                list.Clear();
            }
        }

        private void SendSignals()
        {
            if (Signal.list.Count == 0)
            {
                return;
            }
            foreach (IMyTimerBlock block in GridBlocks.timerBlocks)
            {
                if (Block.HasProperty(block.EntityId, "DOCKED") && Signal.list.ContainsKey(Signal.SignalType.DOCK))
                {
                    Signal.list[Signal.SignalType.DOCK] = 0;
                    Logger.Info("Timer triggered due to Docking accomplished");
                    block.StartCountdown();
                }
                if (Block.HasProperty(block.EntityId, "UNDOCKED") && Signal.list.ContainsKey(Signal.SignalType.ř))
                {
                    Signal.list[Signal.SignalType.ř] = 0;
                    Logger.Info("Timer triggered due to Undocking sequence");
                    block.StartCountdown();
                }
                if (Block.HasProperty(block.EntityId, "NAVIGATED") && Signal.list.ContainsKey(Signal.SignalType.NAVIGATION))
                {
                    Signal.list[Signal.SignalType.NAVIGATION] = 0;
                    Logger.Info("Timer triggered due to Navigation finished");
                    block.StartCountdown()
;
                }
                if (Block.HasProperty(block.EntityId, "STARTED") && Signal.list.ContainsKey(Signal.SignalType.START))
                {
                    Signal.list[Signal.SignalType.START] = 0;
                    Logger.Info("Timer triggered due to Navigation started");
                    block.StartCountdown();
                }
            }
            Signal.UpdateSignals();
        }

        private static class RemoteControl
        { // RemoteControl
            public static IMyRemoteControl block = null; public static bool Present()
            {
                return block != null;
            }

            public static bool PresentOrLog()
            {
                if (Present())
                {
                    return true;
                }
                Logger.Err("No Remote Control!");
                return false;
            }
        }

        private static class ConnectorControl
        { //ConnectorControl
            private static int connectAttempts = 0;
            private static List<IMyShipConnector> connectors = null;

            public static void AttemptConnect()
            {
                connectAttempts = DOCK_ATTEMPTS;
                DoConnect();
            }

            public static void CheckConnect()
            {
                if (connectAttempts == 0)
                {
                    return;
                }
                if (0 == --connectAttempts)
                {
                    Logger.Info("Failed to dock!");
                }
                else
                {
                    DoConnect();
                }
            }

            private static void DoConnect()
            {
                if (!Connect())
                {
                    return;
                }
                connectAttempts = 0;
                Logger.Info("Docking successful!");
                Signal.Send(Signal.SignalType.DOCK);
                if (!Block.HasProperty(GridBlocks.masterProgrammableBlock.EntityId, "NODAMPENERS"))
                {
                    Logistics.Dampeners(false);
                }
            }

            private static List<IMyShipConnector> ListOfConnectors()
            {
                if (GridBlocks.mainShipConnectorBlocks.Count == 0)
                {
                    return GridBlocks.shipConnectorBlocks;
                }
                return GridBlocks.mainShipConnectorBlocks;
            }

            public static IMyShipConnector OtherConnected()
            {
                connectors = ListOfConnectors();
                foreach (IMyShipConnector connector in connectors)
                {
                    if (connector.Status == MyShipConnectorStatus.Connected)
                    {
                        return connector.OtherConnector;
                    }
                }
                return null;
            }

            public static IMyShipConnector Connected()
            {
                connectors = ListOfConnectors();
                foreach (IMyShipConnector connector in connectors)
                {
                    if (connector.Status == MyShipConnectorStatus.Connected)
                    {
                        return connector;
                    }
                }
                return null;
            }

            private static bool connected;
            public static bool Connect()
            {
                connectors = ListOfConnectors();
                connected = false;
                foreach (IMyShipConnector connector in connectors)
                {
                    connector.Connect();
                    if (connector.Status == MyShipConnectorStatus.Connected)
                    {
                        connected = true;
                    }
                }
                return connected;
            }

            private static Vector3D retractVector;
            public static Vector3D Disconnect()
            {
                connectors = ListOfConnectors();
                retractVector = Vector3D.Zero;
                foreach (IMyShipConnector connector in connectors)
                {
                    if (connector.Status == MyShipConnectorStatus.Connected)
                    {
                        connector.Disconnect();
                        retractVector = -connector.WorldMatrix.Forward;
                    }
                }
                return retractVector;
            }

            private static Dock retractDock;
            private static Dock dock;
            public static Dock DisconnectAndTaxiData()
            {
                connectors = ListOfConnectors();
                retractDock = null;
                foreach (IMyShipConnector connector in connectors)
                {
                    if (connector.Status == MyShipConnectorStatus.Connected)
                    {
                        dock = DockData.GetDock(connector.OtherConnector.EntityId);
                        if (dock != null)
                        {
                            retractDock = dock;
                        }
                        else
                        {
                            retractDock = Dock.NewDock(connector.OtherConnector.GetPosition(), connector.OtherConnector.WorldMatrix.Forward, connector.OtherConnector.WorldMatrix.Up, "D");
                        }
                        Signal.Send(Signal.SignalType.ř);
                        connector.Disconnect();
                    }
                }
                return retractDock;
            }

            private static bool reverse;
            public static IMyShipConnector GetConnector(Dock dock)
            {
                connectors = ListOfConnectors();
                if (Math.Abs(Vector3D.Dot(dock.stance.forward, RemoteControl.block.WorldMatrix.Up)) < 0.5f)
                {
                    foreach (IMyShipConnector connector in connectors)
                    {
                        reverse = Block.HasProperty(connector.EntityId, "REV");
                        if (Math.Abs(Vector3D.Dot(reverse ? connector.WorldMatrix.Backward : connector.WorldMatrix.Forward, RemoteControl.block.WorldMatrix.Up)) < 0.5f)
                        {
                            return connector;
                        }
                    }
                }
                else
                {
                    foreach (IMyShipConnector connector in connectors)
                    {
                        reverse = Block.HasProperty(connector.EntityId, "REV");
                        if (Vector3D.Dot(reverse ? connector.WorldMatrix.Backward : connector.WorldMatrix.Forward, -dock.stance.forward) > 0.5f)
                        {
                            return connector;
                        }
                    }
                }
                foreach (IMyShipConnector connector in connectors)
                {
                    return connector;
                }
                return null;
            }
        }

        private static class Pannels2
        {
            public static void Print(long entityId, IMyTextSurface panel)
            {
                if (Block.HasProperty(entityId, "OVR"))
                {
                    return;
                }
                if (Block.HasProperty(entityId, "STAT"))
                {
                    panel.FontSize = 2.5f;
                    panel.Font = "Monospace";
                    panel.TextPadding = 0.0f;
                    return;
                }
                //T.WriteText("surfacesize is " + T.SurfaceSize.Y);
                panel.Font = "Monospace";
                panel.TextPadding = 0.0f;
                if (panel.SurfaceSize.Y < 512)
                {
                    panel.FontSize = 0.6f;
                    return;
                }
                panel.FontSize = 1.180f;
            }
        }

        private static class Terminal
        { // Terminal
            public static List<string> COMMANDS = new List<string> { "step", "run", "loop", "step conf", "run conf", "loop conf", "start", "stop" };
            private static string CMD = "SAMv2 cmd# ";
            private static System.Text.RegularExpressions.Regex cmdRegStr = new System.Text.RegularExpressions.Regex("^" + CMD + "\\s*([\\S ]+)\\s*$");
            private static System.Text.RegularExpressions.Regex navRegStr = new System.Text.RegularExpressions.Regex("^(\\{(\\S+)\\}){0,1}(\\[(\\S+)\\]){0,1}(\\S+)$");
            private static System.Text.RegularExpressions.Regex gpsRegStr = new System.Text.RegularExpressions.Regex(@"^(\{(\S+)\}){0,1}(GPS:[\S\s]+)$");
            private static IMyTextSurface screen;
            private static IMyTextSurface keyboard;
            private static string line; 
            private static string[] str, text, z;
            private static int command;
            private static List<string> cleanLines = new List<string> { };
            private static System.Text.RegularExpressions.Match cmd, navMatch, gpsMatch;
            private static string defaultScreen = "SAMv2 " + VERSION + " \nTo use Remote Commands you must have \na SAM base (ADVERTISER) and\nan LCD with S.A.M.RC\nin the Custom Data.";
            private static string screenText = defaultScreen;
            private static System.Text.StringBuilder stringBuilder = new System.Text.StringBuilder();
            public static void Reset()
            {
                screen.ContentType = VRage.Game.GUI.TextPanel.ContentType.TEXT_AND_IMAGE;
                screen.WriteText(screenText);
                screen.FontSize = 0.6f;
                screen.Font = "Monospace";
                screen.FontColor = Color.Green;
                screen.BackgroundColor = Color.Black;
                screen.TextPadding = 0.0f;
                keyboard.ContentType = VRage.Game.GUI.TextPanel.ContentType.NONE;
            }

            public static void TickReader(Program programmableBlock)
            {
                if (GridBlocks.masterProgrammableBlock == null)
                {
                    return;
                }
                screen = GridBlocks.masterProgrammableBlock.GetSurface(0);
                keyboard = GridBlocks.masterProgrammableBlock.GetSurface(1);
                if (screen == null || keyboard == null)
                {
                    return;
                }
                if (GridBlocks.masterProgrammableBlock.CustomName.Contains("ADVERTISE") || GridBlocks.masterProgrammableBlock.CustomData.Contains("ADVERTISE"))
                {
                    screenText = "SAMv2 " + VERSION + " \nTo use Remote Commands on servers\nYou must have an LCD with \nS.A.M.RC\nin the Custom Data.";
                    programmableBlock.GridTerminalSystem.GetBlocksOfType<IMyTextPanel>(programmableBlock.lcds);
                    if (programmableBlock.lcds.Count() == 0)
                    {
                        return;
                    }

                    foreach (IMyTextPanel panel in programmableBlock.lcds)
                    {
                        if (programmableBlock.lcdfound == false)
                        {
                            screen.WriteText("looking at text panel " + panel.CustomName);

                            if (panel.IsSameConstructAs(GridBlocks.masterProgrammableBlock))
                            {
                                screenText = panel.CustomName + " in same construct";
                            }
                        }
                        if (panel.CustomData.Contains("S.A.M.RC"))
                        {
                            programmableBlock.lcd = panel;
                            programmableBlock.lcd.FontSize = 2f;
                            programmableBlock.lcd.Font = "DEBUG";
                            programmableBlock.lcd.TextPadding = 9.8f;
                            programmableBlock.lcd.ContentType = VRage.Game.GUI.TextPanel.ContentType.TEXT_AND_IMAGE;
                            programmableBlock.lcd.WriteText("S.A.M.RC LCD FOUND", false);
                            screenText = "S.A.M.RC LCD FOUND \n- Use LCD to send Remote Commands\nto SAM ships";
                            programmableBlock.lcdfound = true;
                            programmableBlock.lcd.WriteText("SAMv2 " + VERSION + "\n Replace this text\nwith\nSAM RC Commands", false);
                            stringBuilder.Clear();
                            programmableBlock.lcd.ReadText(stringBuilder);
                            break;
                        }
                        else
                        {
                            programmableBlock.lcdfound = false;
                        }
                    }
                    if (programmableBlock.lcdfound == false)
                    {
                        screenText = "SAMv2 " + VERSION + " S.A.M.RC LCD NOT FOUND\nin same construct.\nNo Remote Commands may be issued.";
                        Reset();
                        return;
                    }

                    text = stringBuilder.ToString().Split(';');
                    command = -2;
                    foreach (string line in text)
                    {
                        str = line.Split('\n');
                        if (str.Length == 0)
                        {
                            Reset();
                            return;
                        }
                        if (str[0] == CMD || str[0].Contains("SAMv2 " + VERSION) || str[0].Contains("Replace this text") || str[0].Contains("S.A.M.RC"))
                        {
                            Reset();
                            return;
                        }
                        cleanLines.Clear();
                        foreach (string character in str)
                        {
                            Terminal.line = character.Trim();
                            if (Terminal.line != "")
                            {
                                cleanLines.Add(Terminal.line);
                            }
                        }
                        str = cleanLines.ToArray();
                        if (command == -2)
                        {
                            cmd = cmdRegStr.Match(str[0]);
                            if (!cmd.Success)
                            {
                                screenText = "steve Invalid command. Please try again.";
                                Reset();
                                return;
                            }
                            command = COMMANDS.FindIndex(str => str.ToLower() == cmd.Groups[1].Value);
                        }
                        else
                        {
                            z = new string[str.Length + 1];
                            z[0] = "";
                            Array.Copy(str, 0, z, 1, str.Length);
                            str = z;
                        }
                        if (command == -1)
                        {
                            screenText = "Invalid command: " + cmd.Groups[1].Value + "\n\nAvailable commands are:\n " + string.Join("\n  ", COMMANDS);
                            Reset();
                            return;
                        }
                        if (str.Length == 1)
                        {
                            screenText = "Command must be followed by the ship name.\nExample:\n loop\n ShipName";
                            Reset();
                            return;
                        }
                        shipCommand.ShipName = str[1];
                        if (ParseNav(str.Skip(2).ToArray()))
                        {
                            SendCmd(programmableBlock, command);
                        }
                    }
                }
                Reset();
            }

            private static ShipCommand shipCommand = new ShipCommand();
            private static Dock.JobType jobType;
            private static void SendCmd(Program p, int cmd)
            {
                shipCommand.Command= cmd;
                screenText = Commander.ExecuteCmd(shipCommand);
                if (screenText != "")
                {
                    return;
                }
                Serializer.InitPack();
                Serializer.Pack(shipCommand);
                if (p.lcdfound)
                {
                    p.lcd.WriteText(Serializer.serialized, false);
                }
                p.IGC.SendBroadcastMessage<string>(CMD_TAG, Serializer.serialized);
                screenText = "Command sent.\n Will only be successful if acknowledged...";
                screenText = Serializer.serialized;
            }

            public static void ProcessResponse(string msg)
            {
                screenText = msg;
                Reset();
            }

            public static bool ParseNav(string[] lines)
            {
                shipCommand.navCmds.Clear();
                foreach (string navStr in lines)
                {
                    navMatch = navRegStr.Match(navStr);
                    gpsMatch = gpsRegStr.Match(navStr);
                    if (!navMatch.Success && !navMatch.Success)
                    {
                        screenText = "Invalid navigation format:\n" + navStr + "\nUse:\n {Action}[Grid]DockName\nor:\n {Action}DockName\nor:\n DockName\nor {Action}GPS:...";
                        return false;
                    }
                    var name = navMatch.Groups[2].Value;
                    if (gpsMatch.Success)
                    {
                        name = gpsMatch.Groups[2].Value;
                    }
                    jobType = Dock.JobTypeFromName(name) | Dock.JobTypeFromName(name);
                    if (jobType == Dock.JobType.NONE && name != "")
                    {
                        screenText = "Invalid Action:\n" + name + "\n\nUse one of:\n Charge,Charge&Load,Charge&Unload,\n Load,Unload;";
                        return false;
                    }
                    if (gpsMatch.Success)
                    {
                        var gps = new GPS(gpsMatch.Groups[3].Value);
                        if (!gps.valid)
                        {
                            screenText = "Invalid GPS format;";
                            return false;
                        }
                        shipCommand.navCmds.Add(new NavCmd(jobType, "", "", gps.name, gps.pos));
                    }
                    else
                    {
                        shipCommand.navCmds.Add(new NavCmd(jobType, navMatch.Groups[4].Value, navMatch.Groups[5].Value, "", Vector3D.Zero));
                    }
                }
                return true;
            }
        }

        private static class Pannels
        { // Pannels
            private static List<string> types = new List<string> { "LOG", "NAV", "CONF", "STAT", "DATA" };
            private static Dictionary<string, string> buffer = new Dictionary<string, string>();
            private static Queue<string> selected = new Queue<string>(new List<string> { "NAV", "CONF" });
            private static string printBuffer, screen;
            private static void ResetBuffers()
            {
                foreach (string type in types)
                {
                    buffer[type] = "";
                }
            }

            private static void FillPrintBuffer(string type)
            {
                printBuffer = buffer[type];
                if (printBuffer != "")
                {
                    return;
                }
                screen = selected.Peek();
                switch (type)
                {
                    case "LOG":
                        try
                        {
                            printBuffer = Logger.PrintBuffer(screen == "LOG");
                        }
                        catch (Exception exception) { Logger.Err("PrintBuffer LOG exception: " + exception.Message); }
                        break;

                    case "CONF":
                        try
                        {
                            printBuffer = DockData.ʥ(screen == "CONF");
                        }
                        catch (Exception exception) { Logger.Err("PrintBuffer CONF exception: " + exception.Message); }
                        break;

                    case "NAV":
                        try
                        {
                            printBuffer = DockData.PrintBufferCONF(screen == "NAV");
                        }
                        catch (Exception exception) { Logger.Err("PrintBuffer NAV exception: " + exception.Message); }
                        break;

                    case "STAT":
                        try
                        {
                            printBuffer = DockData.PrintBufferNAV()
;
                        }
                        catch (Exception exception) { Logger.Err("PrintBuffer STAT exception: " + exception.Message); }
                        break;

                    case "DATA":
                        printBuffer = î.I;
                        break;
                }
            }

            public static void Print()
            {
                if (GridBlocks.textPanelBlocks.Count() == 0 && GridBlocks.cockpitBlocks.Count() == 0)
                {
                    return;
                }
                ResetBuffers();
                foreach (IMyTextPanel panel in GridBlocks.textPanelBlocks)
                {
                    if (Block.HasProperty(panel.EntityId, "Name"))
                    {
                        continue;
                    }
                    printBuffer = "";
                    foreach (string type in types)
                    {
                        if (Block.HasProperty(panel.EntityId, type))
                        {
                            FillPrintBuffer(type);
                            break;
                        }
                    }
                    if (printBuffer == "")
                    {
                        FillPrintBuffer(selected.Peek());
                    }
                    panel.ContentType = VRage.Game.GUI.TextPanel.ContentType.TEXT_AND_IMAGE;
                    Pannels2.Print(panel.EntityId, panel);
                    panel.WriteText(printBuffer);
                }
                foreach (IMyCockpit cockpit in GridBlocks.cockpitBlocks)
                {
                    string type = "";
                    for (int i = 0; i < cockpit.SurfaceCount && i < Profile.panelTags.Length; ++i)
                    {
                        if (!Block.GetProperty(cockpit.EntityId, Profile.panelTags[i], ref type))
                        {
                            continue;
                        }
                        IMyTextSurface textPanel = cockpit.GetSurface(i);
                        textPanel.ContentType = VRage.Game.GUI.TextPanel.ContentType.TEXT_AND_IMAGE;
                        switch (type.ToUpper())
                        {
                            case "LOG":
                                FillPrintBuffer("LOG");
                                break;
                            case "NAV":
                                FillPrintBuffer("NAV");
                                break;
                            case "CONF":
                                FillPrintBuffer("CONF");
                                break;
                            case "STAT":
                                FillPrintBuffer("STAT");
                                break;
                            case "DATA":
                                FillPrintBuffer("DATA");
                                break;
                            default:
                                FillPrintBuffer(selected.Peek());
                                break;
                        }
                        textPanel.WriteText(printBuffer);
                        Pannels2.Print(cockpit.EntityId, textPanel);
                    }
                }
            }

            public static string U()
            {
                if (buffer.Count() == 0)
                {
                    ResetBuffers();
                }
                FillPrintBuffer(selected.Peek());
                return printBuffer;
            }

            public static void NextScreen()
            {
                selected.Enqueue(selected.Dequeue()
);
            }

            public enum ScreenAction
            {
                Prev, Next, Select, Add, Rem, AddStance, AddOrbit
            }; public static void ScreenHandle(ScreenAction ì)
            {
                ScreenHandle(ì, "");
            }

            public static void ScreenHandle(ScreenAction ì, string í)
            {
                switch (selected.Peek())
                {
                    case "NAV":
                        DockData.NAVScreenHandle(ì, í);
                        break;
                    case "CONF":
                        DockData.CONFScreenHandle(ì, í);
                        break;
                    case "LOG":
                        break;
                }
            }
        }

        private static class î
        {
            public static string I = "-";
            private static int ï = 0;
            public static void Q(string N)
            {
                I += N + "\n";
            }

            public static void ð()
            {
                ï++;
                if (ï >= 10000000)
                {
                    ï = 0;
                }
                I = "Clears: " + ï.ToString() + "\n";
            }
        }

        private static class ñ
        {
            // variable changed from 28 to 48 by TechCoder
            private static int ò = 28;
            private static int ó = 1;
            private static Dictionary<string, string> ô = new Dictionary<string, string>();
            public static string õ(string ö, bool Ö, bool ø = false)
            {
                if (!ô.ContainsKey(ö))
                {
                    var ù = (ø ? (" SAMv" + Program.VERSION) : "") + (" " + ö + " ");
                    var ú = Ö ? '=' : '-';
                    ù += new String(ú, ò - ù.Length - (ø ? Program.VERSION.Length : 0) - ó);
                    ô[ö] = ù + "\n";
                }
                return Animation.Rotator() + ô
[ö];
            }
        }

        private static class Logger
        { // Logger
            private static List<string> logger = new List<string>();
            private static string str;
            public static void Log(string line)
            {
                logger.Insert(0, line);
                if (logger.Count() > LOG_MAX_LINES)
                {
                    logger.RemoveAt(logger.Count() - 1);
                }
            }

            public static void Clear()
            {
                logger.Clear();
            }

            public static void Debug(string s)
            {
                Log("D: " + s);
            }

            public static void Info(string s)
            {
                Log("I: " + s);
            }

            public static void Warn(string s)
            {
                Log("W: " + s);
            }

            public static void Err(string s)
            {
                Log("E: " + s);
            }

            public static void Pos(string where, ref Vector3D pos)
            {
                Log("GPS:" + where + ":" + pos.X.ToString("F2") + ":" + pos.Y.ToString("F2") + ":" + pos.Z.ToString("F2") + ":FFFFFF:");
            }

            public static string PrintBuffer(bool active)
            {
                str = ñ.õ("Logger", active, true);
                foreach (string line in logger)
                {
                    str += line + "\n";
                }
                return str;
            }
        }

        private string str;
        private void DebugPrintLogging()
        { // DebugPrintLogging
            List<IMyTextPanel> blocks = new List<IMyTextPanel>();
            GridTerminalSystem.GetBlocksOfType<IMyTextPanel>(blocks);
            if (blocks.Count() == 0)
            {
                return;
            }
            Animation.DebugRun();
            str = Logger.PrintBuffer(false);
            foreach (IMyTextPanel panel in blocks)
            {
                if (!panel.CustomName.Contains(TAG) && !panel.CustomName.Contains("LOG"))
                {
                    continue;
                }
                panel.FontSize = 1.180f;
                panel.Font = "Monospace";
                panel.TextPadding = 0.0f;
                panel.WriteText(str);
            }
        }

        private static class Animation
        { // Animation
            private static string[] ROTATOR = new string[] { "|", "/", "-", "\\" };
            private static int rotatorCount = 0;
            private static int debugRotatorCount = 0;
            public static void Run()
            {
                if (++rotatorCount > ROTATOR.Length - 1)
                {
                    rotatorCount = 0;
                }
            }

            public static string Rotator()
            {
                return ROTATOR[rotatorCount];
            }

            public static void DebugRun()
            {
                if (++debugRotatorCount > ROTATOR.Length - 1)
                {
                    debugRotatorCount = 0;
                }
            }

            public static string DebugRotator()
            {
                return ROTATOR[debugRotatorCount];
            }
        }

        private static class Serializer
        {  // Serializer
            public static string[] separator = new string[] { "\n" };
            public static string serialized;
            public static Queue<string> deserialized;
            public static void InitPack()
            {
                serialized = "";
            }

            public static void Pack(string str)
            {
                serialized += str.Replace(separator[0], " ") + separator[0];
            }

            public static void Pack(int val)
            {
                serialized += val.ToString() + separator[0];
            }

            public static void Pack(long val)
            {
                serialized += val.ToString() + separator[0];
            }

            public static void Pack(float val)
            {
                serialized += val.ToString() + separator[0];
            }

            public static void Pack(double val)
            {
                serialized += val.ToString() + separator[0];
            }

            public static void Pack(bool val)
            {
                serialized += (val ? "1" : "0") + separator[0];
            }

            public static void Pack(VRage.Game.MyCubeSize val)
            {
                Pack((int)val);
            }

            public static void Pack(Dock.JobType val)
            {
                Pack((int)val);
            }

            public static void Pack(Vector3D val)
            {
                Pack(val.X);
                Pack(val.Y);
                Pack(val.Z);
            }

            public static void Pack(List<Vector3D> val)
            {
                Pack(val.Count);
                foreach (Vector3D v in val)
                {
                    Pack(v);
                }
            }

            public static void Pack(List<int> val)
            {
                Pack(val.Count);
                foreach (int v in val)
                {
                    Pack(v);
                }
            }

            public static void Pack(Stance val)
            {
                Pack(val.position);
                Pack(val.forward);
                Pack(val.up);
            }

            public static void Pack(Dock val)
            {
                Pack(val.stance);
                Pack(val.approachPath);
                Pack(val.cubeSize);
                Pack(val.gridEntityId);
                Pack(val.gridName);
                Pack(val.blockEntityId);
                Pack(val.blockName);
                Pack(val.lastSeen);
                Pack(val.job);
            }

            public static void Pack(List<Dock> val)
            {
                Pack(val.Count);
                foreach (Dock v in val)
                {
                    Pack(v);
                }
            }

            public static void Pack(Waypoint val)
            {
                Pack(val.stance);
                Pack(val.maxSpeed);
                Pack((int)val.type);
            }

            public static void Pack(List<Waypoint> val)
            {
                Pack(val.Count);
                foreach (Waypoint v in val)
                {
                    Pack(v);
                }
            }

            public static void Pack(VectorPath val)
            {
                Pack(val.position);
                Pack(val.direction);
            }

            public static void Pack(List<VectorPath> val)
            {
                Pack(val.Count);
                foreach (VectorPath v in val)
                {
                    Pack(v);
                }
            }

            public static void Pack(NavCmd val)
            {
                Pack(val.Action);
                Pack(val.Grid);
                Pack(val.Connector);
                Pack(val.GPSName);
                Pack(val.GPSPosition);
            }

            public static void Pack(List<NavCmd> val)
            {
                Pack(val.Count);
                foreach (NavCmd v in val)
                {
                    Pack(v);
                }
            }

            public static void Pack(ShipCommand val)
            {
                Pack(val.Command);
                Pack(val.ShipName);
                Pack(val.navCmds);
            }

            public static void Pack(Commander.Mode val)
            {
                Pack((int)val);
            }

            public static void Pack(ǐ val)
            {
                Pack(val.ö);
                Pack(val.ź);
                Pack(val.Ǒ);
                Pack(val.ž);
                Pack(val.ǒ);
                Pack(val.Ǔ);
            }

            public static void InitUnpack(string str)
            {
                deserialized = new Queue<string>(str.Split(separator, StringSplitOptions.None));
            }

            public static string UnpackString()
            {
                return deserialized.Dequeue();
            }

            public static int UnpackInt()
            {
                return int.Parse(deserialized.Dequeue());
            }

            public static long UnpackLong()
            {
                return long.Parse(deserialized.Dequeue());
            }

            public static float UnpackFloat()
            {
                return float.Parse(deserialized.Dequeue());
            }

            public static double UnpackDouble()
            {
                return double.Parse(deserialized.Dequeue());
            }

            public static bool UnpackBool()
            {
                return deserialized.Dequeue() == "1";
            }

            public static VRage.Game.MyCubeSize UnpackCubeSize()
            {
                return (VRage.Game.MyCubeSize)UnpackInt();
            }

            public static Dock.JobType UnpackDockJobType()
            {
                return (Dock.JobType)UnpackInt();
            }

            public static Vector3D UnpackVector3D()
            {
                return new Vector3D(UnpackDouble(), UnpackDouble(), UnpackDouble());
            }

            public static List<Vector3D> UnpackListVector3D()
            {
                List<Vector3D> val = new List<Vector3D>();
                int count = UnpackInt();
                for (int i = 0; i < count; i++)
                {
                    val.Add(UnpackVector3D());
                }
                return val;
            }

            public static List<int> UnpackListInt()
            {
                List<int> val = new List<int>();
                int count = UnpackInt();
                for (int i = 0; i < count; i++)
                {
                    val.Add(UnpackInt());
                }
                return val;
            }

            public static Stance UnpackStance()
            {
                return new Stance(UnpackVector3D(), UnpackVector3D(), UnpackVector3D());
            }

            public static Dock UnpackDock()
            {
                Dock val = new Dock();
                val.stance = UnpackStance();
                val.approachPath = UnpackListVectorPath();
                val.cubeSize = UnpackCubeSize();
                val.gridEntityId = UnpackLong();
                val.gridName = UnpackString();
                val.blockEntityId = UnpackLong();
                val.blockName = UnpackString();
                val.lastSeen = UnpackLong();
                val.job = UnpackDockJobType();
                return val;
            }

            public static List<Dock> UnpackListDock()
            {
                List<Dock> val = new List<Dock>();
                int count = UnpackInt();
                for (int i = 0; i < count; i++)
                {
                    val.Add(UnpackDock());
                }
                return val;
            }

            public static Waypoint UnpackWaypoint()
            {
                return new Waypoint(UnpackStance(), UnpackFloat(), (Waypoint.wpType)UnpackInt());
            }

            public static List<Waypoint> UnpackListWaypoint()
            {
                List<Waypoint> val = new List<Waypoint>();
                int count = UnpackInt();
                for (int i = 0; i < count; i++)
                {
                    val.Add(UnpackWaypoint());
                }
                return val;
            }

            public static VectorPath UnpackVectorPath()
            {
                return new VectorPath(UnpackVector3D(), UnpackVector3D());
            }

            public static List<VectorPath> UnpackListVectorPath()
            {
                List<VectorPath> val = new List<VectorPath>();
                int count = UnpackInt();
                for (int i = 0; i < count; i++)
                {
                    val.Add(UnpackVectorPath());
                }
                return val;
            }

            public static NavCmd UnpackNavCmd()
            {
                return new NavCmd((Dock.JobType)UnpackInt(), UnpackString(), UnpackString(), UnpackString(), UnpackVector3D());
            }

            public static List<NavCmd> UnpackListNavCmd()
            {
                List<NavCmd> val = new List<NavCmd>();
                int count = UnpackInt();
                for (int i = 0; i < count; i++)
                {
                    val.Add(UnpackNavCmd());
                }
                return val;
            }

            public static ShipCommand UnpackShipCommand()
            {
                ShipCommand sc = new ShipCommand();
                sc.Command = UnpackInt();
                sc.ShipName = UnpackString();
                sc.navCmds = UnpackListNavCmd();
                return sc;
            }

            public static Commander.Mode UnpackCommanderMode()
            {
                return (Commander.Mode)UnpackInt();
            }

            public static ǐ UnpackSomething()
            {
                ǐ ǟ = new ǐ
                {
                    ö = UnpackString(),
                    ź = UnpackVector3D(),
                    Ǒ = UnpackVector3D(),
                    ž = UnpackVector3D(),
                    ǒ = UnpackVector3D(),
                    Ǔ = UnpackFloat()
                };
                return ǟ;
            }
        }

        private struct ǐ
        {
            public string ö;
            public Vector3D ź;
            public Vector3D Ǒ;
            public Vector3D ž;
            public Vector3D ǒ;
            public double Ǔ;
        }

        private static class Helper
        {
            // Helper
            public static string FormatedWaypoint(bool stance, int pos)
            {
                return (stance ? "Ori " : "Pos ") + (++pos).ToString("D2");
            }
        }

        private class GPS
        { // GPS
            public string name;
            public Vector3D pos;
            public bool valid = false;
            private string[] parts;
            public GPS(string gps)
            {
                parts = gps.Split(':');
                if (parts.Length != 6 && parts.Length != 7)
                {
                    return;
                }
                try
                {
                    name = parts[1];
                    pos = new Vector3D(double.Parse(parts[2]), double.Parse(parts[3]), double.Parse(parts[4]));
                }
                catch
                {
                    return;
                }
                valid = true;
            }
        }

        private static class ErrorState
        { // ErrorState
            public enum Type
            {
                TooManyControllers, NoRemoteController
            };
            private static Dictionary<Type, bool> errorState = new Dictionary<Type, bool> { };
            public static void Set(Type type)
            {
                errorState[type] = true;
            }

            public static void Reset(Type type)
            {
                errorState[type] = false;
            }

            public static bool Get(Type type)
            {
                if (!errorState.ContainsKey(type))
                {
                    return false;
                }
                return errorState[type];
            }
        }

        private class Stance
        { // Stance
            public Vector3D position;
            public Vector3D forward;
            public Vector3D up;
            public Stance(Vector3D pos, Vector3D fwd, Vector3D up)
            {
                this.position = pos;
                this.forward = fwd;
                this.up = up;
            }
        }

        private class VectorPath
        { // VectorPath
            public Vector3D position;
            public Vector3D direction;
            public VectorPath(Vector3D pos, Vector3D direction)
            {
                this.position = pos;
                this.direction = direction;
            }
        }

        private class Waypoint
        { // Waypoint
            public Stance stance;
            public float maxSpeed;
            public enum wpType { 
                ALIGNING, DOCKING, UNDOCKING, CONVERGING, NAVIGATING, TAXIING, APPROACHING, FOLLOWING, HOPPING
            };
            public wpType type;

            public Waypoint(Stance stance, float maxSpeed, wpType waypointType)
            {
                this.stance = stance;
                this.maxSpeed = maxSpeed;
                type = waypointType;
            }

            public string GetTypeMsg()
            {
                switch (this.type)
                {
                    case wpType.ALIGNING:
                        return "aligning...";
                    case wpType.DOCKING:
                        return "docking...";
                    case wpType.UNDOCKING:
                        return "undocking...";
                    case wpType.APPROACHING:
                        return "approaching...";
                    case wpType.CONVERGING:
                        return "converging...";
                    case wpType.NAVIGATING:
                        return "navigating...";
                    case wpType.TAXIING:
                        return "taxiing...";
                    case wpType.FOLLOWING:
                        return "following...";
                    case wpType.HOPPING:
                        return "hopping...";
                }
                return "Testing...";
            }

            public static Waypoint FromString(string coordinates)
            {
                GPS gps = new GPS(coordinates);
                return new Waypoint(new Stance(gps.pos, Vector3D.Zero, Vector3D.Zero), MAX_SPEED, wpType.CONVERGING);
            }
        }

        private class PairCounter
        { // PairCounter
            public int oldC;
            public int newC;
            public PairCounter()
            {
                this.oldC = 0;
                this.newC = 1;
            }

            public void Recount()
            {
                this.oldC = this.newC;
                this.newC = 0;
            }

            public int Diff()
            {
                return newC - oldC;
            }
        }

        private class BlockProfile
        { // BlockProfile
            public string[] tags;
            public string[] exclusiveTags;
            public string[] attributes;
            public BlockProfile(ref string[] tags, ref string[] exclusiveTags, ref string[] attributes)
            {
                this.tags = tags;
                this.exclusiveTags = exclusiveTags;
                this.attributes = attributes;
            }

            public string Capitalize(string str)
            {
                foreach (string attribute in attributes)
                {
                    if (attribute.ToLower() == str.ToLower())
                    {
                        return attribute;
                    }
                }
                return "";
            }
        }

        private class Dock : IComparable<Dock>
        { // Dock:IComparable<Dock>
            private static long STALE_TIME = TimeSpan.FromSeconds(60.0).Ticks;

            public static Dock NewDock(Vector3D pos, Vector3D fwd, Vector3D up, string name)
            {
                Dock dock = new Dock();
                dock.stance = new Stance(pos, fwd, up);
                dock.gridName = "Manual";
                dock.blockName = name;
                return dock;
            }

            public Stance stance;
            public List<VectorPath> approachPath = new List<VectorPath>();
            public VRage.Game.MyCubeSize cubeSize;
            public long gridEntityId = 0;
            public string gridName = "";
            public long blockEntityId = 0;
            public string blockName = "";
            public long lastSeen = 0;

            public enum JobType
            {
                NONE, CHARGE, LOAD, UNLOAD, CHARGE_LOAD, CHARGE_UNLOAD, HOP, DISCHARGE
            };

            public JobType job = JobType.NONE;
            public void NextJob()
            {
                int i = (int)job;
                if (++i == Enum.GetNames(typeof(JobType)).Length)
                {
                    i = 0;
                }
                job = (JobType)i;
            }

            public string JobName()
            {
                switch (job)
                {
                    case JobType.NONE:
                        return "None";

                    case JobType.CHARGE:
                        return "Charge";

                    case JobType.LOAD:
                        return "Load";

                    case JobType.UNLOAD:
                        return "Unload";

                    case JobType.CHARGE_LOAD:
                        return "Charge&Load";

                    case JobType.CHARGE_UNLOAD:
                        return "Charge&Unload";

                    case JobType.HOP:
                        return "Hop";

                    case JobType.DISCHARGE:
                        return "Discharge";
                }
                return "";
            }
            
            public static JobType JobTypeFromName(string name)
            {
                switch (name.ToLower())
                {
                    case "charge":
                        return JobType.CHARGE;

                    case "load":
                        return JobType.LOAD;

                    case "unload":
                        return JobType.UNLOAD;

                    case "charge&load":
                        return JobType.CHARGE_LOAD;

                    case "charge&unload":
                        return JobType.CHARGE_UNLOAD;

                    case "hop":
                        return JobType.HOP;

                    case "discharge":
                        return JobType.DISCHARGE;
                }
                return JobType.NONE;
            }

            public int CompareTo(Dock other)
            {
                if (this.gridEntityId != other.gridEntityId)
                {
                    return (other.gridEntityId < this.gridEntityId) ? 1 : -1;
                }
                if (this.blockEntityId != other.blockEntityId)
                {
                    return (other.blockEntityId < this.blockEntityId) ? 1 : -1;
                }
                return this.blockName.CompareTo(other.blockName);
            }

            public void SortApproachVectorsByDistance(Vector3D from)
            {
                approachPath.Sort(delegate (VectorPath a, VectorPath b)
                {
                    return (int)(Vector3D.Distance(from, b.position) - Vector3D.Distance(from, a.position));
                });
            }

            public void Touch()
            {
                this.lastSeen = DateTime.Now.Ticks;
            }

            public bool Fresh()
            {
                if (lastSeen == 0)
                {
                    return true;
                }
                return (DateTime.Now.Ticks - lastSeen) < STALE_TIME;
            }
        }

        private class NavCmd
        {
            public Dock.JobType Action;
            public string Grid;
            public string Connector;
            public string GPSName;
            public Vector3D GPSPosition;

            public NavCmd(Dock.JobType action, string grid, string connector, string gpsName, Vector3D gpsPosition)
            {
                this.Action = action;
                this.Grid = grid;
                this.Connector = connector;
                this.GPSName = gpsName;
                this.GPSPosition = gpsPosition;
            }
        }

        private class ShipCommand
        { // NavCmd
            public int Command;
            public string ShipName;
            public List<NavCmd> navCmds = new List<NavCmd> { };
        }

        private class ShipCommand2
        { // ShipCommand
            private class ƚ
            {
                public float ƛ;
                public float Ɯ;
                public float Ɲ;

                public ƚ(float ƞ)
                {
                    Ɲ = Ɯ = ƛ = ƞ;
                }

                public void Ɵ(float ƞ)
                {
                    ƛ = Math.Min(ƛ, ƞ);
                    Ɲ = Math.Max(Ɲ, ƞ);
                    Ɯ = 0.9f * Ɯ + 0.1f * ƞ;
                }
            }

            private Dictionary<UpdateType, ƚ> Ơ = new Dictionary<UpdateType, ƚ>();

            public void Ɵ(float ƞ, UpdateType ơ)
            {
                if (!Ơ.ContainsKey(ơ))
                {
                    Ơ[ơ] = new ƚ(ƞ);
                    return;
                }
                Ơ[ơ].Ɵ(ƞ);
            }

            public string Ƣ()
            {
                var è = "Load: Min/Avg/Max\n";
                foreach (var Ƥ in Ơ)
                {
                    è += String.Format("{1:P1} {2:P1} {3:P1} :{0}\n", Ƥ.Key, Ƥ.Value.ƛ, Ƥ.Value.Ɯ, Ƥ.Value.Ɲ);
                }
                return è;
            }
        }
    }
}